#!/usr/bin/env python3
"""
RTOS AI 代碼生成器
使用 AI 自動生成 FreeRTOS/Zephyr/RT-Thread 代碼

作者: AI-Assisted Development Team
日期: 2025-11-18
版本: 1.0.0
"""

import argparse
import json
import sys
from typing import Dict, List, Any
from dataclasses import dataclass
from enum import Enum


class RTOSType(Enum):
    """RTOS 類型"""
    FREERTOS = "freertos"
    ZEPHYR = "zephyr"
    RT_THREAD = "rt-thread"


class ComponentType(Enum):
    """組件類型"""
    TASK = "task"
    QUEUE = "queue"
    SEMAPHORE = "semaphore"
    MUTEX = "mutex"
    EVENT_GROUP = "event_group"
    TIMER = "timer"
    ISR = "isr"


@dataclass
class TaskConfig:
    """任務配置"""
    name: str
    priority: int
    stack_size: int
    function_name: str
    description: str
    parameters: List[str] = None


@dataclass
class QueueConfig:
    """佇列配置"""
    name: str
    length: int
    item_size: str
    description: str


class RTOSCodeGenerator:
    """RTOS 代碼生成器基類"""

    def __init__(self, rtos_type: RTOSType):
        self.rtos_type = rtos_type

    def generate_header(self, project_name: str) -> str:
        """生成文件頭"""
        return f"""/**
 * @file {project_name}.c
 * @brief Auto-generated {self.rtos_type.value.upper()} application
 * @author RTOS AI Code Generator
 * @date 2025-11-18
 *
 * This file was automatically generated by the RTOS AI Code Generator.
 * Please review and customize as needed.
 */

"""

    def generate_includes(self) -> str:
        """生成包含文件"""
        raise NotImplementedError

    def generate_task(self, config: TaskConfig) -> str:
        """生成任務代碼"""
        raise NotImplementedError

    def generate_queue(self, config: QueueConfig) -> str:
        """生成佇列代碼"""
        raise NotImplementedError


class FreeRTOSGenerator(RTOSCodeGenerator):
    """FreeRTOS 代碼生成器"""

    def __init__(self):
        super().__init__(RTOSType.FREERTOS)

    def generate_includes(self) -> str:
        return """#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "timers.h"
#include "event_groups.h"
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

"""

    def generate_task(self, config: TaskConfig) -> str:
        params = ', '.join(config.parameters) if config.parameters else ""
        return f"""/**
 * @brief {config.description}
 * @param pvParameters Task parameters
 */
void {config.function_name}(void *pvParameters)
{{
    TickType_t xLastWakeTime;
    const TickType_t xFrequency = pdMS_TO_TICKS(1000);  /* 1 second */

    /* Initialize the xLastWakeTime variable */
    xLastWakeTime = xTaskGetTickCount();

    printf("[{config.name}] Task started\\n");

    while (1) {{
        /* Task implementation goes here */
        printf("[{config.name}] Running\\n");

        /* Wait for the next cycle */
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }}
}}

"""

    def generate_queue(self, config: QueueConfig) -> str:
        return f"""/* {config.description} */
QueueHandle_t {config.name} = NULL;

void create_{config.name}(void)
{{
    {config.name} = xQueueCreate({config.length}, sizeof({config.item_size}));

    if ({config.name} == NULL) {{
        printf("ERROR: Failed to create queue {config.name}\\n");
    }} else {{
        printf("Queue {config.name} created successfully\\n");
    }}
}}

"""

    def generate_semaphore(self, name: str, sem_type: str) -> str:
        """生成信號量代碼"""
        create_func = {
            'binary': 'xSemaphoreCreateBinary',
            'counting': 'xSemaphoreCreateCounting',
            'mutex': 'xSemaphoreCreateMutex'
        }.get(sem_type, 'xSemaphoreCreateBinary')

        return f"""/* {sem_type.capitalize()} Semaphore: {name} */
SemaphoreHandle_t {name} = NULL;

void create_{name}(void)
{{
    {name} = {create_func}();

    if ({name} == NULL) {{
        printf("ERROR: Failed to create semaphore {name}\\n");
    }} else {{
        printf("Semaphore {name} created successfully\\n");
    }}
}}

"""

    def generate_main(self, tasks: List[TaskConfig], project_name: str) -> str:
        """生成 main 函數"""
        code = """int main(void)
{
    /* HAL initialization */
    HAL_Init();
    SystemClock_Config();

    /* UART initialization for printf */
    UART_Init();

    printf("\\n");
    printf("========================================\\n");
    printf("  %s\\n");
    printf("  Generated by RTOS AI Code Generator\\n");
    printf("========================================\\n\\n");

""" % project_name

        # 創建任務
        for task in tasks:
            code += f"""    /* Create task: {task.name} */
    xTaskCreate({task.function_name},
                "{task.name}",
                {task.stack_size},
                NULL,
                {task.priority},
                NULL);

"""

        code += """    printf("All tasks created successfully!\\n");
    printf("Starting FreeRTOS scheduler...\\n\\n");

    /* Start scheduler */
    vTaskStartScheduler();

    /* Should never reach here */
    printf("ERROR: Scheduler failed to start!\\n");

    while (1);

    return 0;
}
"""
        return code


class ZephyrGenerator(RTOSCodeGenerator):
    """Zephyr RTOS 代碼生成器"""

    def __init__(self):
        super().__init__(RTOSType.ZEPHYR)

    def generate_includes(self) -> str:
        return """#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/printk.h>
#include <stdint.h>
#include <stdbool.h>

"""

    def generate_task(self, config: TaskConfig) -> str:
        return f"""/**
 * @brief {config.description}
 */
void {config.function_name}(void *arg1, void *arg2, void *arg3)
{{
    printk("[{config.name}] Thread started\\n");

    while (1) {{
        /* Thread implementation goes here */
        printk("[{config.name}] Running\\n");

        /* Sleep for 1 second */
        k_sleep(K_MSEC(1000));
    }}
}}

/* Define thread stack */
K_THREAD_STACK_DEFINE({config.name}_stack, {config.stack_size});

/* Thread structure */
struct k_thread {config.name}_data;

"""

    def generate_main(self, tasks: List[TaskConfig], project_name: str) -> str:
        code = """int main(void)
{
    printk("\\n");
    printk("========================================\\n");
    printk("  %s\\n");
    printk("  Generated by RTOS AI Code Generator\\n");
    printk("========================================\\n\\n");

""" % project_name

        # 創建線程
        for task in tasks:
            code += f"""    /* Create thread: {task.name} */
    k_thread_create(&{task.name}_data, {task.name}_stack,
                    K_THREAD_STACK_SIZEOF({task.name}_stack),
                    {task.function_name},
                    NULL, NULL, NULL,
                    {task.priority}, 0, K_NO_WAIT);
    k_thread_name_set(&{task.name}_data, "{task.name}");

"""

        code += """    printk("All threads created successfully!\\n\\n");

    return 0;
}
"""
        return code


class RTThreadGenerator(RTOSCodeGenerator):
    """RT-Thread 代碼生成器"""

    def __init__(self):
        super().__init__(RTOSType.RT_THREAD)

    def generate_includes(self) -> str:
        return """#include <rtthread.h>
#include <rtdevice.h>
#include <board.h>
#include <stdint.h>
#include <stdbool.h>

"""

    def generate_task(self, config: TaskConfig) -> str:
        return f"""/**
 * @brief {config.description}
 */
void {config.function_name}(void *parameter)
{{
    rt_kprintf("[{config.name}] Thread started\\n");

    while (1) {{
        /* Thread implementation goes here */
        rt_kprintf("[{config.name}] Running\\n");

        /* Delay 1 second */
        rt_thread_mdelay(1000);
    }}
}}

"""

    def generate_main(self, tasks: List[TaskConfig], project_name: str) -> str:
        code = """int main(void)
{
    rt_kprintf("\\n");
    rt_kprintf("========================================\\n");
    rt_kprintf("  %s\\n", \"""" + project_name + """\");
    rt_kprintf("  Generated by RTOS AI Code Generator\\n");
    rt_kprintf("========================================\\n\\n");

"""

        # 創建線程
        for task in tasks:
            code += f"""    /* Create thread: {task.name} */
    rt_thread_t {task.name}_thread = rt_thread_create(
        "{task.name}",
        {task.function_name},
        NULL,
        {task.stack_size},
        {task.priority},
        20
    );

    if ({task.name}_thread != NULL) {{
        rt_thread_startup({task.name}_thread);
        rt_kprintf("Thread {task.name} created successfully\\n");
    }} else {{
        rt_kprintf("ERROR: Failed to create thread {task.name}\\n");
    }}

"""

        code += """    return 0;
}
"""
        return code


class AIAssistant:
    """AI 輔助功能"""

    @staticmethod
    def suggest_stack_size(task_description: str) -> int:
        """根據任務描述建議堆疊大小"""
        keywords_sizes = {
            'simple': 256,
            'led': 256,
            'blink': 256,
            'button': 256,
            'sensor': 512,
            'i2c': 512,
            'spi': 512,
            'uart': 512,
            'network': 2048,
            'tcp': 2048,
            'http': 2048,
            'file': 1024,
            'filesystem': 1024,
            'display': 1024,
            'gui': 2048,
        }

        description_lower = task_description.lower()
        for keyword, size in keywords_sizes.items():
            if keyword in description_lower:
                return size

        return 512  # 默認大小

    @staticmethod
    def suggest_priority(task_description: str) -> int:
        """根據任務描述建議優先級"""
        # 優先級: 1=最低, 5=最高
        keywords_priorities = {
            'critical': 5,
            'high': 4,
            'isr': 5,
            'interrupt': 5,
            'sensor': 3,
            'data': 3,
            'network': 2,
            'display': 2,
            'logging': 1,
            'monitor': 1,
            'idle': 1,
        }

        description_lower = task_description.lower()
        for keyword, priority in keywords_priorities.items():
            if keyword in description_lower:
                return priority

        return 2  # 默認優先級

    @staticmethod
    def generate_project_structure(project_name: str) -> Dict[str, Any]:
        """生成項目結構建議"""
        return {
            "project_name": project_name,
            "directories": [
                "src",
                "include",
                "build",
                "docs",
                "tests"
            ],
            "files": [
                "src/main.c",
                "src/tasks.c",
                "include/config.h",
                "include/tasks.h",
                "Makefile",
                "CMakeLists.txt",
                "README.md"
            ],
            "recommended_tools": [
                "GCC ARM Embedded",
                "OpenOCD",
                "GDB",
                "VS Code + Cortex-Debug"
            ]
        }


def create_generator(rtos_type: str) -> RTOSCodeGenerator:
    """創建代碼生成器"""
    generators = {
        'freertos': FreeRTOSGenerator,
        'zephyr': ZephyrGenerator,
        'rt-thread': RTThreadGenerator,
    }

    generator_class = generators.get(rtos_type.lower())
    if not generator_class:
        raise ValueError(f"Unsupported RTOS type: {rtos_type}")

    return generator_class()


def generate_code_from_config(config_file: str, output_file: str):
    """從配置文件生成代碼"""
    with open(config_file, 'r') as f:
        config = json.load(f)

    rtos_type = config.get('rtos_type', 'freertos')
    project_name = config.get('project_name', 'my_rtos_app')

    generator = create_generator(rtos_type)

    # 解析任務配置
    tasks = []
    for task_cfg in config.get('tasks', []):
        task = TaskConfig(
            name=task_cfg['name'],
            priority=task_cfg.get('priority',
                AIAssistant.suggest_priority(task_cfg.get('description', ''))),
            stack_size=task_cfg.get('stack_size',
                AIAssistant.suggest_stack_size(task_cfg.get('description', ''))),
            function_name=task_cfg.get('function_name', f"v{task_cfg['name']}Task"),
            description=task_cfg.get('description', ''),
            parameters=task_cfg.get('parameters', [])
        )
        tasks.append(task)

    # 生成代碼
    code = generator.generate_header(project_name)
    code += generator.generate_includes()
    code += "\n/* ==================== Task Implementations ==================== */\n\n"

    for task in tasks:
        code += generator.generate_task(task)

    code += "\n/* ==================== Main Function ==================== */\n\n"
    code += generator.generate_main(tasks, project_name)

    # 寫入文件
    with open(output_file, 'w') as f:
        f.write(code)

    print(f"✓ Generated code written to: {output_file}")
    print(f"  RTOS: {rtos_type}")
    print(f"  Tasks: {len(tasks)}")


def interactive_mode():
    """交互式模式"""
    print("\n╔═══════════════════════════════════════════╗")
    print("║   RTOS AI Code Generator - Interactive   ║")
    print("╚═══════════════════════════════════════════╝\n")

    # 選擇 RTOS
    print("Select RTOS type:")
    print("  1) FreeRTOS")
    print("  2) Zephyr")
    print("  3) RT-Thread")

    choice = input("\nYour choice (1-3): ")
    rtos_map = {'1': 'freertos', '2': 'zephyr', '3': 'rt-thread'}
    rtos_type = rtos_map.get(choice, 'freertos')

    # 項目名稱
    project_name = input("Project name: ") or "my_rtos_app"

    # 任務配置
    tasks = []
    print("\nConfiguring tasks (press Enter with empty name to finish):")

    while True:
        print(f"\n--- Task #{len(tasks) + 1} ---")
        name = input("Task name: ")
        if not name:
            break

        description = input("Description: ")

        # AI 建議
        suggested_stack = AIAssistant.suggest_stack_size(description)
        suggested_priority = AIAssistant.suggest_priority(description)

        print(f"  Suggested stack size: {suggested_stack}")
        print(f"  Suggested priority: {suggested_priority}")

        stack_size = input(f"Stack size [{suggested_stack}]: ") or str(suggested_stack)
        priority = input(f"Priority [{suggested_priority}]: ") or str(suggested_priority)

        task = TaskConfig(
            name=name,
            priority=int(priority),
            stack_size=int(stack_size),
            function_name=f"v{name}Task",
            description=description
        )
        tasks.append(task)

    if not tasks:
        print("\nNo tasks configured. Exiting.")
        return

    # 生成代碼
    output_file = f"{project_name}.c"
    generator = create_generator(rtos_type)

    code = generator.generate_header(project_name)
    code += generator.generate_includes()
    code += "\n/* ==================== Task Implementations ==================== */\n\n"

    for task in tasks:
        code += generator.generate_task(task)

    code += "\n/* ==================== Main Function ==================== */\n\n"
    code += generator.generate_main(tasks, project_name)

    with open(output_file, 'w') as f:
        f.write(code)

    print(f"\n✓ Successfully generated: {output_file}")
    print(f"  RTOS: {rtos_type}")
    print(f"  Tasks: {len(tasks)}")


def main():
    parser = argparse.ArgumentParser(
        description='RTOS AI Code Generator - Generate RTOS code automatically'
    )

    parser.add_argument(
        '-c', '--config',
        help='Configuration file (JSON)',
        type=str
    )

    parser.add_argument(
        '-o', '--output',
        help='Output file',
        type=str,
        default='generated_app.c'
    )

    parser.add_argument(
        '-i', '--interactive',
        help='Interactive mode',
        action='store_true'
    )

    args = parser.parse_args()

    try:
        if args.interactive:
            interactive_mode()
        elif args.config:
            generate_code_from_config(args.config, args.output)
        else:
            print("Error: Please specify --config or --interactive")
            parser.print_help()
            sys.exit(1)

    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
