# â±ï¸ å³æ™‚ä½œæ¥­ç³»çµ± (RTOS) é–‹ç™¼
> ä½¿ç”¨ AI é©…å‹•çš„æ–¹æ³•é€²è¡Œå³æ™‚ä½œæ¥­ç³»çµ±é–‹ç™¼

âš ï¸ **é©—è­‰éšæ®µå°ˆæ¡ˆ** - æ­¤é ˜åŸŸç›®å‰è™•æ–¼ç ”ç©¶èˆ‡é–‹ç™¼éšæ®µ

## ğŸ“‹ å°ˆæ¡ˆæ¦‚è¿°

å³æ™‚ä½œæ¥­ç³»çµ± (Real-Time Operating System, RTOS) æ˜¯ä¸€ç¨®èƒ½å¤ åœ¨ç¢ºå®šæ™‚é–“å…§éŸ¿æ‡‰å¤–éƒ¨äº‹ä»¶çš„ä½œæ¥­ç³»çµ±ï¼Œå»£æ³›æ‡‰ç”¨æ–¼å·¥æ¥­æ§åˆ¶ã€æ±½è»Šé›»å­ã€é†«ç™‚è¨­å‚™ç­‰é ˜åŸŸã€‚æœ¬å°ˆæ¡ˆå±•ç¤ºå¦‚ä½•ä½¿ç”¨ AI è¼”åŠ©å·¥å…·é€²è¡Œ RTOS é–‹ç™¼å’Œå„ªåŒ–ã€‚

## ğŸ¯ æ”¯æ´çš„ RTOS

### 1. FreeRTOS
- **æœ€æµè¡Œçš„é–‹æº RTOS**
  - ä»»å‹™ç®¡ç†
  - ä½‡åˆ— (Queue)
  - ä¿¡è™Ÿé‡ (Semaphore)
  - äº’æ–¥é– (Mutex)
  - äº‹ä»¶çµ„ (Event Groups)
  - è»Ÿé«”å®šæ™‚å™¨

- **æ‡‰ç”¨é ˜åŸŸ**
  - IoT è¨­å‚™
  - æ¶ˆè²»é›»å­
  - å·¥æ¥­æ§åˆ¶
  - é†«ç™‚è¨­å‚™

### 2. Zephyr RTOS
- **ç¾ä»£ç‰©è¯ç¶² RTOS**
  - å¤šå¹³å°æ”¯æ´
  - è¨­å‚™æ¨¹é…ç½®
  - è±å¯Œçš„é©…å‹•åº«
  - è—ç‰™/Wi-Fi å †ç–Š
  - OTA æ›´æ–°

- **ç‰¹è‰²åŠŸèƒ½**
  - West å·¥å…·éˆ
  - Kconfig é…ç½®
  - è¨­å‚™æ¨¡å‹
  - é›»æºç®¡ç†

### 3. RT-Thread
- **ä¸­åœ‹é–‹æº RTOS**
  - ç‰©ä»¶å°å‘è¨­è¨ˆ
  - è¨­å‚™æ¡†æ¶
  - çµ„ä»¶è±å¯Œ
  - ä¸­æ–‡æ–‡æª”å®Œå–„

- **çµ„ä»¶ç³»çµ±**
  - ç¶²è·¯å”è­°æ£§
  - æª”æ¡ˆç³»çµ±
  - GUI æ¡†æ¶
  - è¨­å‚™é©…å‹•

### 4. VxWorks
- **å·¥æ¥­ç´šå•†ç”¨ RTOS**
  - ç¡¬å³æ™‚æ€§èƒ½
  - é«˜å¯é æ€§
  - POSIX ç›¸å®¹
  - å®‰å…¨èªè­‰

- **æ‡‰ç”¨å ´æ™¯**
  - èˆªç©ºèˆªå¤©
  - åœ‹é˜²è»å·¥
  - å·¥æ¥­è‡ªå‹•åŒ–
  - é†«ç™‚è¨­å‚™

### 5. QNX
- **å¾®æ ¸å¿ƒ RTOS**
  - è¨Šæ¯å‚³éæ©Ÿåˆ¶
  - æ¨¡çµ„åŒ–è¨­è¨ˆ
  - å®¹éŒ¯èƒ½åŠ›å¼·
  - æ±½è»Šç´šèªè­‰

- **æ‡‰ç”¨é ˜åŸŸ**
  - æ±½è»Šé›»å­
  - é†«ç™‚ç³»çµ±
  - å·¥æ¥­æ§åˆ¶
  - éµè·¯ç³»çµ±

### 6. Azure RTOS (ThreadX)
- **Microsoft RTOS**
  - å°è¨˜æ†¶é«”ä½”ç”¨
  - å¿«é€Ÿä¸Šä¸‹æ–‡åˆ‡æ›
  - å„ªå…ˆæ¬Šç¹¼æ‰¿
  - Azure IoT æ•´åˆ

### 7. RIOT OS
- **ç‰©è¯ç¶² RTOS**
  - é¡ Linux API
  - ç¶²è·¯å”è­°è±å¯Œ
  - ä½åŠŸè€—è¨­è¨ˆ
  - æ¨¡çµ„åŒ–æ¶æ§‹

### 8. NuttX
- **POSIX ç›¸å®¹ RTOS**
  - é¡ Unix æ¶æ§‹
  - è±å¯Œçš„é©…å‹•
  - ç¶²è·¯å †ç–Š
  - æª”æ¡ˆç³»çµ±æ”¯æ´

## ğŸ› ï¸ æŠ€è¡“æ£§

### é–‹ç™¼èªè¨€
- **C** - RTOS ä¸»è¦èªè¨€
- **C++** - ç‰©ä»¶å°å‘æ‡‰ç”¨
- **Assembly** - ä¸Šä¸‹æ–‡åˆ‡æ›
- **Python** - é…ç½®å’Œå·¥å…·

### é–‹ç™¼å·¥å…·
- **IDE**
  - STM32CubeIDE (FreeRTOS)
  - Zephyr SDK
  - RT-Thread Studio
  - SEGGER Embedded Studio

- **é™¤éŒ¯å·¥å…·**
  - SEGGER SystemView
  - FreeRTOS Trace
  - RTOS-aware GDB
  - Logic Analyzer

## ğŸš€ å¿«é€Ÿé–‹å§‹

### 1. FreeRTOS åŸºç¤ç¯„ä¾‹

```c
// main.c - FreeRTOS åŸºæœ¬ä»»å‹™
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

#define TASK_STACK_SIZE 128

// ä»»å‹™å¥æŸ„
TaskHandle_t task1_handle;
TaskHandle_t task2_handle;

// ä½‡åˆ—å¥æŸ„
QueueHandle_t data_queue;

// ä»»å‹™ 1: LED é–ƒçˆ
void vTask1(void *pvParameters)
{
    uint32_t counter = 0;

    while (1) {
        // åˆ‡æ› LED
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);

        // ç™¼é€æ•¸æ“šåˆ°ä½‡åˆ—
        xQueueSend(data_queue, &counter, portMAX_DELAY);
        counter++;

        // å»¶é² 500ms
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

// ä»»å‹™ 2: æ•¸æ“šè™•ç†
void vTask2(void *pvParameters)
{
    uint32_t received_data;

    while (1) {
        // å¾ä½‡åˆ—æ¥æ”¶æ•¸æ“š
        if (xQueueReceive(data_queue, &received_data, portMAX_DELAY) == pdTRUE) {
            printf("Received: %lu\n", received_data);
        }
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    GPIO_Init();
    UART_Init();

    // å‰µå»ºä½‡åˆ— (10 å€‹å…ƒç´ )
    data_queue = xQueueCreate(10, sizeof(uint32_t));

    // å‰µå»ºä»»å‹™ 1 (å„ªå…ˆæ¬Š 2)
    xTaskCreate(vTask1,
                "Task1",
                TASK_STACK_SIZE,
                NULL,
                2,
                &task1_handle);

    // å‰µå»ºä»»å‹™ 2 (å„ªå…ˆæ¬Š 3)
    xTaskCreate(vTask2,
                "Task2",
                TASK_STACK_SIZE,
                NULL,
                3,
                &task2_handle);

    // å•Ÿå‹•æ’ç¨‹å™¨
    vTaskStartScheduler();

    // ä¸æ‡‰è©²åˆ°é”é€™è£¡
    while (1);

    return 0;
}
```

### 2. FreeRTOS åŒæ­¥æ©Ÿåˆ¶

```c
// semaphore_example.c
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

SemaphoreHandle_t binary_semaphore;
SemaphoreHandle_t counting_semaphore;
SemaphoreHandle_t mutex;

// å…±äº«è³‡æº
static int shared_resource = 0;

// ç”Ÿç”¢è€…ä»»å‹™
void producer_task(void *pvParameters)
{
    while (1) {
        // ç”Ÿç”¢æ•¸æ“š
        vTaskDelay(pdMS_TO_TICKS(100));

        // é‡‹æ”¾è¨ˆæ•¸ä¿¡è™Ÿé‡
        xSemaphoreGive(counting_semaphore);
    }
}

// æ¶ˆè²»è€…ä»»å‹™
void consumer_task(void *pvParameters)
{
    while (1) {
        // ç­‰å¾…ä¿¡è™Ÿé‡
        if (xSemaphoreTake(counting_semaphore, portMAX_DELAY) == pdTRUE) {
            printf("Consumed data\n");
        }
    }
}

// è‡¨ç•Œå€ä¿è­·ä»»å‹™
void critical_task(void *pvParameters)
{
    while (1) {
        // ç²å–äº’æ–¥é–
        if (xSemaphoreTake(mutex, portMAX_DELAY) == pdTRUE) {
            // è‡¨ç•Œå€
            shared_resource++;
            printf("Resource: %d\n", shared_resource);

            // é‡‹æ”¾äº’æ–¥é–
            xSemaphoreGive(mutex);
        }

        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

void setup_synchronization(void)
{
    // å‰µå»ºäºŒé€²åˆ¶ä¿¡è™Ÿé‡
    binary_semaphore = xSemaphoreCreateBinary();

    // å‰µå»ºè¨ˆæ•¸ä¿¡è™Ÿé‡ (æœ€å¤§è¨ˆæ•¸ 10)
    counting_semaphore = xSemaphoreCreateCounting(10, 0);

    // å‰µå»ºäº’æ–¥é–
    mutex = xSemaphoreCreateMutex();

    // å‰µå»ºä»»å‹™
    xTaskCreate(producer_task, "Producer", 128, NULL, 2, NULL);
    xTaskCreate(consumer_task, "Consumer", 128, NULL, 2, NULL);
    xTaskCreate(critical_task, "Critical", 128, NULL, 3, NULL);
}
```

### 3. FreeRTOS äº‹ä»¶çµ„

```c
// event_group_example.c
#include "FreeRTOS.h"
#include "task.h"
#include "event_groups.h"

// äº‹ä»¶ä½å®šç¾©
#define EVENT_BIT_0  (1 << 0)  // æŒ‰éˆ•æŒ‰ä¸‹
#define EVENT_BIT_1  (1 << 1)  // æ•¸æ“šæ¥æ”¶
#define EVENT_BIT_2  (1 << 2)  // å®šæ™‚å™¨åˆ°æœŸ

EventGroupHandle_t event_group;

// äº‹ä»¶è¨­ç½®ä»»å‹™
void event_setter_task(void *pvParameters)
{
    while (1) {
        // æª¢æŸ¥æŒ‰éˆ•
        if (button_pressed()) {
            xEventGroupSetBits(event_group, EVENT_BIT_0);
        }

        // æª¢æŸ¥æ•¸æ“š
        if (data_available()) {
            xEventGroupSetBits(event_group, EVENT_BIT_1);
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// äº‹ä»¶ç­‰å¾…ä»»å‹™
void event_waiter_task(void *pvParameters)
{
    const EventBits_t bits_to_wait = EVENT_BIT_0 | EVENT_BIT_1;

    while (1) {
        // ç­‰å¾…ä»»ä¸€äº‹ä»¶ (OR)
        EventBits_t bits = xEventGroupWaitBits(
            event_group,
            bits_to_wait,
            pdTRUE,   // æ¸…é™¤ä½
            pdFALSE,  // ç­‰å¾…ä»»ä¸€ä½
            portMAX_DELAY
        );

        if (bits & EVENT_BIT_0) {
            printf("Button pressed!\n");
        }

        if (bits & EVENT_BIT_1) {
            printf("Data received!\n");
        }
    }
}

// ç­‰å¾…æ‰€æœ‰äº‹ä»¶
void wait_all_events_task(void *pvParameters)
{
    const EventBits_t all_bits = EVENT_BIT_0 | EVENT_BIT_1 | EVENT_BIT_2;

    while (1) {
        // ç­‰å¾…æ‰€æœ‰äº‹ä»¶ (AND)
        xEventGroupWaitBits(
            event_group,
            all_bits,
            pdTRUE,   // æ¸…é™¤ä½
            pdTRUE,   // ç­‰å¾…æ‰€æœ‰ä½
            portMAX_DELAY
        );

        printf("All events occurred!\n");
    }
}
```

### 4. FreeRTOS è»Ÿé«”å®šæ™‚å™¨

```c
// timer_example.c
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"

TimerHandle_t one_shot_timer;
TimerHandle_t auto_reload_timer;

// ä¸€æ¬¡æ€§å®šæ™‚å™¨å›èª¿
void one_shot_callback(TimerHandle_t xTimer)
{
    printf("One-shot timer expired!\n");
    // å®šæ™‚å™¨è‡ªå‹•åœæ­¢
}

// è‡ªå‹•é‡è¼‰å®šæ™‚å™¨å›èª¿
void auto_reload_callback(TimerHandle_t xTimer)
{
    static uint32_t count = 0;
    printf("Auto-reload timer: %lu\n", count++);
}

void setup_timers(void)
{
    // å‰µå»ºä¸€æ¬¡æ€§å®šæ™‚å™¨ (5 ç§’)
    one_shot_timer = xTimerCreate(
        "OneShot",
        pdMS_TO_TICKS(5000),
        pdFALSE,  // ä¸€æ¬¡æ€§
        (void *)0,
        one_shot_callback
    );

    // å‰µå»ºè‡ªå‹•é‡è¼‰å®šæ™‚å™¨ (1 ç§’)
    auto_reload_timer = xTimerCreate(
        "AutoReload",
        pdMS_TO_TICKS(1000),
        pdTRUE,   // è‡ªå‹•é‡è¼‰
        (void *)0,
        auto_reload_callback
    );

    // å•Ÿå‹•å®šæ™‚å™¨
    xTimerStart(one_shot_timer, 0);
    xTimerStart(auto_reload_timer, 0);
}

// å‹•æ…‹æ§åˆ¶å®šæ™‚å™¨
void control_timer_task(void *pvParameters)
{
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(10000));

        // åœæ­¢å®šæ™‚å™¨
        xTimerStop(auto_reload_timer, 0);
        printf("Timer stopped\n");

        vTaskDelay(pdMS_TO_TICKS(5000));

        // é‡å•Ÿå®šæ™‚å™¨
        xTimerStart(auto_reload_timer, 0);
        printf("Timer restarted\n");
    }
}
```

### 5. Zephyr RTOS ç¯„ä¾‹

```c
// zephyr_example.c
#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>

#define LED_NODE DT_ALIAS(led0)
#define STACKSIZE 1024
#define PRIORITY 7

static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED_NODE, gpios);

// å®šç¾©ç·šç¨‹å †ç–Š
K_THREAD_STACK_DEFINE(thread1_stack, STACKSIZE);
K_THREAD_STACK_DEFINE(thread2_stack, STACKSIZE);

// ç·šç¨‹çµæ§‹
struct k_thread thread1_data;
struct k_thread thread2_data;

// å®šç¾©ä½‡åˆ—
K_MSGQ_DEFINE(my_msgq, sizeof(uint32_t), 10, 4);

// ç·šç¨‹ 1
void thread1(void *arg1, void *arg2, void *arg3)
{
    uint32_t data = 0;

    while (1) {
        // ç™¼é€åˆ°ä½‡åˆ—
        k_msgq_put(&my_msgq, &data, K_NO_WAIT);
        data++;

        // åˆ‡æ› LED
        gpio_pin_toggle_dt(&led);

        k_sleep(K_MSEC(500));
    }
}

// ç·šç¨‹ 2
void thread2(void *arg1, void *arg2, void *arg3)
{
    uint32_t received;

    while (1) {
        // å¾ä½‡åˆ—æ¥æ”¶
        if (k_msgq_get(&my_msgq, &received, K_FOREVER) == 0) {
            printk("Received: %u\n", received);
        }
    }
}

int main(void)
{
    // é…ç½® GPIO
    gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);

    // å‰µå»ºç·šç¨‹
    k_thread_create(&thread1_data, thread1_stack,
                    K_THREAD_STACK_SIZEOF(thread1_stack),
                    thread1, NULL, NULL, NULL,
                    PRIORITY, 0, K_NO_WAIT);

    k_thread_create(&thread2_data, thread2_stack,
                    K_THREAD_STACK_SIZEOF(thread2_stack),
                    thread2, NULL, NULL, NULL,
                    PRIORITY, 0, K_NO_WAIT);

    return 0;
}
```

## ğŸ“š é–‹ç™¼ç¯„ä¾‹

### ç¯„ä¾‹ 1: å„ªå…ˆæ¬Šåè½‰è§£æ±º

```c
// priority_inversion.c
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

SemaphoreHandle_t mutex_with_priority_inheritance;

// ä½å„ªå…ˆæ¬Šä»»å‹™
void low_priority_task(void *pvParameters)
{
    while (1) {
        if (xSemaphoreTake(mutex_with_priority_inheritance, portMAX_DELAY)) {
            printf("Low priority task working\n");
            vTaskDelay(pdMS_TO_TICKS(100));  // æ¨¡æ“¬å·¥ä½œ
            xSemaphoreGive(mutex_with_priority_inheritance);
        }
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

// ä¸­å„ªå…ˆæ¬Šä»»å‹™
void medium_priority_task(void *pvParameters)
{
    while (1) {
        printf("Medium priority task running\n");
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

// é«˜å„ªå…ˆæ¬Šä»»å‹™
void high_priority_task(void *pvParameters)
{
    vTaskDelay(pdMS_TO_TICKS(50));  // å»¶é²å•Ÿå‹•

    while (1) {
        if (xSemaphoreTake(mutex_with_priority_inheritance, portMAX_DELAY)) {
            printf("High priority task working\n");
            xSemaphoreGive(mutex_with_priority_inheritance);
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void setup_priority_inheritance(void)
{
    // å‰µå»ºæ”¯æ´å„ªå…ˆæ¬Šç¹¼æ‰¿çš„äº’æ–¥é–
    mutex_with_priority_inheritance = xSemaphoreCreateMutex();

    xTaskCreate(low_priority_task, "Low", 128, NULL, 1, NULL);
    xTaskCreate(medium_priority_task, "Medium", 128, NULL, 2, NULL);
    xTaskCreate(high_priority_task, "High", 128, NULL, 3, NULL);
}
```

### ç¯„ä¾‹ 2: ä»»å‹™é€šçŸ¥

```c
// task_notification.c
#include "FreeRTOS.h"
#include "task.h"

TaskHandle_t receiver_task_handle;

// æ¥æ”¶ä»»å‹™
void receiver_task(void *pvParameters)
{
    uint32_t notification_value;

    while (1) {
        // ç­‰å¾…ä»»å‹™é€šçŸ¥
        if (xTaskNotifyWait(0, 0xFFFFFFFF, &notification_value, portMAX_DELAY)) {
            printf("Received notification: 0x%08lX\n", notification_value);
        }
    }
}

// ç™¼é€ä»»å‹™
void sender_task(void *pvParameters)
{
    uint32_t count = 0;

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));

        // ç™¼é€ä»»å‹™é€šçŸ¥
        xTaskNotify(receiver_task_handle, count++, eSetValueWithOverwrite);
    }
}

// ISR ä¸­ç™¼é€é€šçŸ¥
void EXTI0_IRQHandler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // å¾ ISR ç™¼é€é€šçŸ¥
    vTaskNotifyGiveFromISR(receiver_task_handle, &xHigherPriorityTaskWoken);

    // ä¸Šä¸‹æ–‡åˆ‡æ›
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

## ğŸ¤– AI è¼”åŠ©é–‹ç™¼ç­–ç•¥

### 1. RTOS æ¶æ§‹è¨­è¨ˆ
```
"è¨­è¨ˆä¸€å€‹å¤šä»»å‹™ç³»çµ±çš„ä»»å‹™åŠƒåˆ†ç­–ç•¥"
"å¦‚ä½•é¸æ“‡åˆé©çš„ä»»å‹™å„ªå…ˆæ¬Šï¼Ÿ"
"RTOS å †ç–Šå¤§å°å¦‚ä½•è¨ˆç®—ï¼Ÿ"
```

### 2. ç¨‹å¼ç¢¼ç”Ÿæˆ
```
"ç”Ÿæˆ FreeRTOS çš„ç”Ÿç”¢è€…-æ¶ˆè²»è€…æ¨¡å¼"
"å‰µå»ºå¤šä»»å‹™é€šè¨Šçš„ä½‡åˆ—ç³»çµ±"
"å¯¦ä½œä»»å‹™ç›£æ§å’Œçµ±è¨ˆåŠŸèƒ½"
```

### 3. é™¤éŒ¯å”åŠ©
```
"ä»»å‹™å †ç–Šæº¢ä½å¦‚ä½•æ’æŸ¥ï¼Ÿ"
"å„ªå…ˆæ¬Šåè½‰å•é¡Œå¦‚ä½•è§£æ±ºï¼Ÿ"
"æ­»é–å¦‚ä½•æª¢æ¸¬å’Œé é˜²ï¼Ÿ"
```

### 4. æ€§èƒ½å„ªåŒ–
```
"å¦‚ä½•æ¸›å°‘ä¸Šä¸‹æ–‡åˆ‡æ›é–‹éŠ·ï¼Ÿ"
"RTOS è¨˜æ†¶é«”ä½¿ç”¨å„ªåŒ–"
"å³æ™‚æ€§èƒ½å¦‚ä½•ä¿è­‰ï¼Ÿ"
```

## ğŸ“Š å°ˆæ¡ˆçµæ§‹

```
rtos/
â”œâ”€â”€ README.md                       # æœ¬æ–‡ä»¶
â”œâ”€â”€ docs/                           # å®Œæ•´æ–‡æª”
â”‚   â”œâ”€â”€ getting-started.md         # å…¥é–€æŒ‡å—
â”‚   â””â”€â”€ rtos-comparison.md         # RTOS è©³ç´°å°æ¯”
â”œâ”€â”€ freertos/                       # FreeRTOS å°ˆæ¡ˆ
â”‚   â”œâ”€â”€ task-management/           # ä»»å‹™ç®¡ç†ï¼ˆå«å®Œæ•´æ§‹å»ºç³»çµ±ï¼‰
â”‚   â”‚   â”œâ”€â”€ src/                   # æºä»£ç¢¼
â”‚   â”‚   â”œâ”€â”€ include/               # é ­æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ Makefile              # GNU Make æ§‹å»º
â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt        # CMake æ§‹å»º
â”‚   â”‚   â””â”€â”€ build.sh              # è‡ªå‹•åŒ–æ§‹å»ºè…³æœ¬
â”‚   â””â”€â”€ synchronization/           # åŒæ­¥æ©Ÿåˆ¶ç¯„ä¾‹
â”œâ”€â”€ zephyr/                         # Zephyr RTOS
â”‚   â””â”€â”€ basic-blinky/              # LED é–ƒçˆç¯„ä¾‹
â”œâ”€â”€ rt-thread/                      # RT-Thread
â”‚   â””â”€â”€ iot-gateway/               # IoT é–˜é“å™¨
â”œâ”€â”€ examples/                       # å®Œæ•´ç¯„ä¾‹é›†
â”‚   â”œâ”€â”€ freertos/                  # FreeRTOS ç¯„ä¾‹
â”‚   â”‚   â”œâ”€â”€ 01-task-management/   # ä»»å‹™ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ 02-synchronization/   # åŒæ­¥æ©Ÿåˆ¶
â”‚   â”‚   â”œâ”€â”€ 03-interrupts/        # ä¸­æ–·è™•ç†
â”‚   â”‚   â”œâ”€â”€ 04-memory-management/ # è¨˜æ†¶é«”ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ 05-real-world-projects/ # å¯¦éš›å°ˆæ¡ˆ
â”‚   â”‚   â””â”€â”€ 06-power-management/  # é›»æºç®¡ç† ğŸ†•
â”‚   â”œâ”€â”€ zephyr/                    # Zephyr ç¯„ä¾‹
â”‚   â””â”€â”€ rt-thread/                 # RT-Thread ç¯„ä¾‹
â””â”€â”€ tools/                          # é–‹ç™¼å·¥å…· ğŸ†•
    â”œâ”€â”€ ai-assistant/              # AI è¼”åŠ©å·¥å…·
    â”‚   â”œâ”€â”€ rtos_code_generator.py # ä»£ç¢¼ç”Ÿæˆå™¨
    â”‚   â”œâ”€â”€ config_optimizer.py    # é…ç½®å„ªåŒ–å™¨
    â”‚   â””â”€â”€ example_config.json    # é…ç½®ç¤ºä¾‹
    â”œâ”€â”€ debug/                     # èª¿è©¦é…ç½®
    â”‚   â”œâ”€â”€ .gdbinit              # GDB é…ç½®
    â”‚   â””â”€â”€ openocd.cfg           # OpenOCD é…ç½®
    â””â”€â”€ benchmark/                 # æ€§èƒ½æ¸¬è©¦
        â””â”€â”€ benchmark_suite.c      # åŸºæº–æ¸¬è©¦å¥—ä»¶
```

## âœ¨ æ–°å¢åŠŸèƒ½ï¼ˆ2025-11-18 æ›´æ–°ï¼‰

### ğŸ—ï¸ æ§‹å»ºç³»çµ±
- **å®Œæ•´çš„æ§‹å»ºæ”¯æ´**: ç‚º FreeRTOS é …ç›®æ·»åŠ  Makefile å’Œ CMake æ§‹å»ºç³»çµ±
- **è‡ªå‹•åŒ–è…³æœ¬**: build.sh ä¸€éµæ§‹å»ºã€ç‡’éŒ„ã€èª¿è©¦
- **äº¤å‰ç·¨è­¯**: ARM GCC å·¥å…·éˆå®Œæ•´é…ç½®
- **è¨˜æ†¶é«”åˆ†æ**: è‡ªå‹•ç”Ÿæˆè¨˜æ†¶é«”ä½¿ç”¨å ±å‘Š

### âš¡ é›»æºç®¡ç†
- **Tickless Idle**: è‡ªå‹•ä½åŠŸè€—æ¨¡å¼ï¼Œå¯ç¯€çœé«˜é” 98% åŠŸè€—
- **å¤šç´šä½åŠŸè€—**: Sleep/Stop/Standby æ¨¡å¼å®Œæ•´å¯¦ç¾
- **åŠŸè€—åˆ†æ**: å¯¦æ™‚åŠŸè€—ç›£æ¸¬å’Œé›»æ± å£½å‘½é æ¸¬
- **DVFS æ”¯æ´**: å‹•æ…‹é›»å£“å’Œé »ç‡èª¿æ•´

### ğŸ¤– AI è¼”åŠ©å·¥å…·
- **ä»£ç¢¼ç”Ÿæˆå™¨**: æ ¹æ“šé…ç½®è‡ªå‹•ç”Ÿæˆ RTOS æ‡‰ç”¨æ¡†æ¶
  - æ”¯æ´ FreeRTOSã€Zephyrã€RT-Thread
  - AI æ™ºèƒ½æ¨è–¦å †ç–Šå¤§å°å’Œå„ªå…ˆç´š
  - äº¤äº’å¼å’Œé…ç½®æ–‡ä»¶å…©ç¨®æ¨¡å¼

- **é…ç½®å„ªåŒ–å™¨**: è‡ªå‹•åˆ†æå’Œå„ªåŒ– RTOS é…ç½®
  - æª¢æ¸¬é…ç½®å•é¡Œå’Œå®‰å…¨éš±æ‚£
  - æä¾›å„ªåŒ–å»ºè­°å’Œæœ€ä½³å¯¦è¸
  - é›»æºå„ªåŒ–åˆ†æ

### ğŸ”§ èª¿è©¦å·¥å…·
- **GDB é…ç½®**: å®Œæ•´çš„ GDB åˆå§‹åŒ–è…³æœ¬
  - FreeRTOS ä»»å‹™æ„ŸçŸ¥èª¿è©¦
  - Cortex-M å¯„å­˜å™¨å’Œ NVIC æŸ¥çœ‹
  - è‡ªå‹• HardFault åˆ†æ
  - å †ç–Šä½¿ç”¨æª¢æŸ¥

- **OpenOCD é…ç½®**: å°ˆæ¥­çš„ç‡’éŒ„å’Œèª¿è©¦é…ç½®
  - ST-Link æ”¯æ´
  - RTOS æ„ŸçŸ¥èª¿è©¦
  - ITM/SWO è¿½è¹¤
  - è‡ªå®šç¾©èª¿è©¦å‘½ä»¤

### ğŸ“Š æ€§èƒ½æ¸¬è©¦
- **åŸºæº–æ¸¬è©¦å¥—ä»¶**: å®Œæ•´çš„æ€§èƒ½æ¸¬è©¦å·¥å…·
  - ä¸Šä¸‹æ–‡åˆ‡æ›æ€§èƒ½ (~1.5Î¼s)
  - ä¿¡è™Ÿé‡/äº’æ–¥é–æ€§èƒ½
  - ä½‡åˆ—ååé‡æ¸¬è©¦
  - è¨˜æ†¶é«”åˆ†é…æ€§èƒ½
  - ä½¿ç”¨ DWT ç²¾ç¢ºè¨ˆæ™‚

## ğŸ§ª é–‹ç™¼è·¯ç·šåœ–

### Phase 1: åŸºç¤æ¦‚å¿µ âœ…
- [x] ä»»å‹™å‰µå»º
- [x] ä»»å‹™èª¿åº¦
- [x] ä½‡åˆ—é€šè¨Š
- [x] ä¿¡è™Ÿé‡

### Phase 2: é€²éšåŠŸèƒ½ âœ…
- [x] äº‹ä»¶çµ„
- [x] è»Ÿé«”å®šæ™‚å™¨
- [x] ä»»å‹™é€šçŸ¥
- [x] å„ªå…ˆæ¬Šç¹¼æ‰¿
- [x] å®Œæ•´æ§‹å»ºç³»çµ±
- [x] AI è¼”åŠ©å·¥å…·

### Phase 3: ç³»çµ±å„ªåŒ– âœ…
- [x] å †ç–Šå„ªåŒ–
- [x] å³æ™‚æ€§èƒ½æ¸¬è©¦
- [x] åŠŸè€—ç®¡ç†ï¼ˆTickless Idleï¼‰
- [x] éŒ¯èª¤è™•ç†å’Œèª¿è©¦å·¥å…·

### Phase 4: æ‡‰ç”¨é–‹ç™¼ â³
- [x] å®Œæ•´æ•¸æ“šæ¡é›†ç³»çµ±
- [x] IoT é–˜é“å™¨
- [x] æ€§èƒ½åŸºæº–æ¸¬è©¦
- [ ] OTA æ›´æ–°
- [ ] ç¶²çµ¡å”è­°æ£§ï¼ˆlwIPï¼‰
- [ ] å®‰å…¨åŠŸèƒ½ï¼ˆåŠ å¯†ã€å®‰å…¨å•Ÿå‹•ï¼‰

## ğŸš€ å¿«é€Ÿé–‹å§‹

### 1. ä½¿ç”¨ AI ä»£ç¢¼ç”Ÿæˆå™¨å‰µå»ºé …ç›®

```bash
# äº¤äº’å¼æ¨¡å¼
cd tools/ai-assistant
python3 rtos_code_generator.py --interactive

# å¾é…ç½®æ–‡ä»¶ç”Ÿæˆ
python3 rtos_code_generator.py --config example_config.json --output my_app.c
```

### 2. æ§‹å»ºå’Œç‡’éŒ„

```bash
cd freertos/task-management

# ä½¿ç”¨ Make æ§‹å»º
make clean && make
make flash

# æˆ–ä½¿ç”¨ CMake
./build.sh cmake
```

### 3. èª¿è©¦

```bash
# å•Ÿå‹• OpenOCDï¼ˆçµ‚ç«¯ 1ï¼‰
openocd -f tools/debug/openocd.cfg

# å•Ÿå‹• GDBï¼ˆçµ‚ç«¯ 2ï¼‰
arm-none-eabi-gdb build/firmware.elf
```

### 4. æ€§èƒ½æ¸¬è©¦

```bash
# é‹è¡ŒåŸºæº–æ¸¬è©¦å¥—ä»¶
cd tools/benchmark
make && make flash

# æŸ¥çœ‹æ€§èƒ½å ±å‘Šï¼ˆé€šéä¸²å£ï¼‰
minicom -D /dev/ttyUSB0 -b 115200
```

### 5. é…ç½®å„ªåŒ–

```bash
# åˆ†æé…ç½®æ–‡ä»¶
python3 tools/ai-assistant/config_optimizer.py \
    freertos/task-management/include/FreeRTOSConfig.h

# ç”Ÿæˆå„ªåŒ–é…ç½®
python3 tools/ai-assistant/config_optimizer.py \
    freertos/task-management/include/FreeRTOSConfig.h \
    --output FreeRTOSConfig_optimized.h \
    --power
```

## ğŸ“ˆ æ€§èƒ½æŒ‡æ¨™

### FreeRTOS æ€§èƒ½ï¼ˆSTM32F407 @ 168MHzï¼‰

| æ“ä½œ | æ€§èƒ½ | èªªæ˜ |
|------|------|------|
| ä¸Šä¸‹æ–‡åˆ‡æ› | ~1.5Î¼s | ä»»å‹™é–“åˆ‡æ›æ™‚é–“ |
| ä¿¡è™Ÿé‡æ“ä½œ | ~0.8Î¼s | Take/Give æ“ä½œ |
| ä½‡åˆ—æ“ä½œ | ~1.2Î¼s | Send/Receive |
| ä»»å‹™é€šçŸ¥ | ~0.5Î¼s | æœ€å¿«çš„ IPC |
| è¨˜æ†¶é«”åˆ†é… | ~2.0Î¼s | 128 å­—ç¯€ |

### åŠŸè€—å„ªåŒ–ï¼ˆé›»æ± ä¾›é›»æ‡‰ç”¨ï¼‰

| æ¨¡å¼ | åŠŸè€— | ç¯€çœ | é©ç”¨å ´æ™¯ |
|------|------|------|---------|
| ç„¡å„ªåŒ– | 100mA | 0% | æŒçºŒé‹è¡Œ |
| Sleep æ¨¡å¼ | 15mA | 85% | é€±æœŸæ¡æ¨£ï¼ˆ1Hzï¼‰ |
| Stop æ¨¡å¼ | 2mA | 98% | ä½é »æ¡æ¨£ï¼ˆ0.1Hzï¼‰ |
| Standby | 50Î¼A | 99.95% | å¾…æ©Ÿæ¨¡å¼ |

## ğŸ”¬ å­¸ç¿’è³‡æº

### æ›¸ç±æ¨è–¦
1. **Mastering the FreeRTOS Real Time Kernel**
2. **Real-Time Embedded Systems** - Xiaocong Fan
3. **The Definitive Guide to ARM Cortex-M3/M4**

### ç·šä¸Šè³‡æº
- [FreeRTOS.org](https://www.freertos.org/)
- [Zephyr Project](https://www.zephyrproject.org/)
- [RT-Thread Documentation](https://www.rt-thread.io/)

### æœ¬é …ç›®æ–‡æª”
- [å…¥é–€æŒ‡å—](docs/getting-started.md) - è©³ç´°çš„ RTOS é–‹ç™¼æ•™ç¨‹
- [RTOS å°æ¯”](docs/rtos-comparison.md) - æ·±åº¦æŠ€è¡“å°æ¯”åˆ†æ
- [é›»æºç®¡ç†](examples/freertos/06-power-management/README.md) - ä½åŠŸè€—é–‹ç™¼æŒ‡å—
- [AI å·¥å…·ä½¿ç”¨](tools/ai-assistant/README.md) - AI è¼”åŠ©å·¥å…·å®Œæ•´æ•™ç¨‹

## âš™ï¸ é–‹ç™¼æœ€ä½³å¯¦è¸

### 1. ä»»å‹™è¨­è¨ˆåŸå‰‡
- å–®ä¸€è·è²¬
- é©ç•¶å„ªå…ˆæ¬Š
- é¿å…å¿™ç­‰å¾…
- åˆç†å †ç–Šå¤§å°

### 2. åŒæ­¥æ©Ÿåˆ¶é¸æ“‡
- äºŒé€²åˆ¶ä¿¡è™Ÿé‡: äº‹ä»¶é€šçŸ¥
- è¨ˆæ•¸ä¿¡è™Ÿé‡: è³‡æºè¨ˆæ•¸
- äº’æ–¥é–: å…±äº«è³‡æºä¿è­·
- äº‹ä»¶çµ„: å¤šäº‹ä»¶åŒæ­¥

### 3. é¿å…å¸¸è¦‹éŒ¯èª¤
- å †ç–Šæº¢ä½
- å„ªå…ˆæ¬Šåè½‰
- æ­»é–
- è³‡æºæ´©æ¼

## âš ï¸ æ³¨æ„äº‹é …

### å³æ™‚æ€§è€ƒæ…®
- é—œéµä»»å‹™å„ªå…ˆæ¬Šæœ€é«˜
- ISR è™•ç†æ™‚é–“æœ€å°åŒ–
- ç¦ç”¨ä¸­æ–·æ™‚é–“è¦çŸ­
- é¿å…åœ¨ ISR ä¸­é˜»å¡

## ğŸ“„ æˆæ¬Š

ç¯„ä¾‹ä»£ç¢¼æ¡ç”¨ MIT æˆæ¬Š

---

**æœ€å¾Œæ›´æ–°**: 2025-11-16
**ç‹€æ…‹**: ğŸš§ ç ”ç©¶èˆ‡é–‹ç™¼ä¸­
**ç¶­è­·è€…**: AI-Assisted Development Team
