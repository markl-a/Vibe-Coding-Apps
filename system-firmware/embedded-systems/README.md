# âš¡ åµŒå…¥å¼ç³»çµ±é–‹ç™¼
> ä½¿ç”¨ AI é©…å‹•çš„æ–¹æ³•é€²è¡ŒåµŒå…¥å¼ç³»çµ±é–‹ç™¼

âš ï¸ **é©—è­‰éšæ®µå°ˆæ¡ˆ** - æ­¤é ˜åŸŸç›®å‰è™•æ–¼ç ”ç©¶èˆ‡é–‹ç™¼éšæ®µ

## ğŸ‰ æœ€æ–°æ›´æ–°ï¼ˆ2025-11-18ï¼‰

### âœ¨ æ–°å¢åŠŸèƒ½

**ğŸ¤– AI è¼”åŠ©é–‹ç™¼å·¥å…·**
- GPIO/I2C ä»£ç¢¼è‡ªå‹•ç”Ÿæˆå™¨ï¼ˆæ”¯æ´ STM32/ESP32/Arduino/RPiï¼‰
- å´©æ½°æ—¥èªŒæ™ºèƒ½åˆ†æå·¥å…·ï¼ˆHardFault è¨ºæ–·ï¼‰
- å®Œæ•´çš„ AI æç¤ºç¯„æœ¬åº«

**âš¡ STM32 é€²éšç¯„ä¾‹**
- ADC + DMA é«˜é€Ÿæ¡æ¨£ç³»çµ±ï¼ˆ800 KSPSï¼ŒCPU ä½¿ç”¨ç‡ <5%ï¼‰
- é«˜ç´š PWM æ§åˆ¶ï¼ˆäº’è£œè¼¸å‡ºã€æ­»å€æ™‚é–“ã€ç·¨ç¢¼å™¨ï¼‰
- ä½åŠŸè€—æ¨¡å¼æ¼”ç¤ºï¼ˆSleep/Stop/Standbyï¼Œæœ€ä½ 0.4 ÂµAï¼‰

**ğŸ§  ESP32 AI/ML åŠŸèƒ½**
- TensorFlow Lite æ¨è«–å¼•æ“ï¼ˆ<50ms æ¨è«–æ™‚é–“ï¼‰
- èªéŸ³/æ‰‹å‹¢/åœ–åƒè­˜åˆ¥æ”¯æ´
- é‚Šç·£ AI é‹ç®—ç¯„ä¾‹

**ğŸ“¡ ESP32 OTA æ›´æ–°**
- HTTPS å®‰å…¨å›ºä»¶æ›´æ–°
- è‡ªå‹•å›æ»¾æ©Ÿåˆ¶
- å›ºä»¶ç°½åé©—è­‰
- æ‰¹é‡è¨­å‚™ç®¡ç†

**ğŸ  å¯¦éš›æ‡‰ç”¨ç¯„ä¾‹**
- å®Œæ•´çš„æ™ºæ…§å®¶å±…ä¸­æ¨ç³»çµ±
- å¤šæ„Ÿæ¸¬å™¨æ•´åˆï¼ˆæº«æ¿•åº¦ã€å…‰ç…§ã€äººé«”ã€ç…™éœ§ï¼‰
- MQTT é ç«¯æ§åˆ¶
- Web æ§åˆ¶é¢æ¿
- è‡ªå‹•åŒ–å ´æ™¯

### ğŸ“Š é …ç›®çµ±è¨ˆ

- **ä»£ç¢¼ç¯„ä¾‹**: 30+ å€‹å®Œæ•´ç¯„ä¾‹
- **æ”¯æ´å¹³å°**: 8 å€‹ä¸»æµå¹³å°
- **æ–‡æª”é é¢**: 2000+ è¡ŒæŠ€è¡“æ–‡æª”
- **AI å·¥å…·**: 5 å€‹è‡ªå‹•åŒ–å·¥å…·
- **å¯¦éš›æ‡‰ç”¨**: 1 å€‹å®Œæ•´æ™ºæ…§å®¶å±…ç³»çµ±

### ğŸš€ å¿«é€Ÿå°èˆª

| é¡åˆ¥ | å…§å®¹ | è·¯å¾‘ |
|------|------|------|
| ğŸ¤– AI å·¥å…· | ä»£ç¢¼ç”Ÿæˆå™¨ã€é™¤éŒ¯åŠ©æ‰‹ | [ai-tools/](ai-tools/) |
| âš¡ STM32 é€²éš | ADC/DMAã€PWMã€ä½åŠŸè€— | [stm32/examples/](stm32/examples/) |
| ğŸ§  ESP32 AI | TensorFlow Lite æ¨è«– | [esp32/ai-ml/](esp32/ai-ml/) |
| ğŸ“¡ ESP32 OTA | å®‰å…¨å›ºä»¶æ›´æ–° | [esp32/ota/](esp32/ota/) |
| ğŸ  å¯¦éš›æ‡‰ç”¨ | æ™ºæ…§å®¶å±…ç³»çµ± | [examples/smart-home/](examples/smart-home/) |
| ğŸ“š æ–‡æª” | å…¥é–€æŒ‡å—ã€æœ€ä½³å¯¦è¸ | [docs/](docs/) |

## ğŸ“‹ å°ˆæ¡ˆæ¦‚è¿°

åµŒå…¥å¼ç³»çµ±æ˜¯ç¾ä»£é›»å­ç”¢å“çš„æ ¸å¿ƒï¼Œå¾ç‰©è¯ç¶²è¨­å‚™åˆ°å·¥æ¥­æ§åˆ¶ç³»çµ±ç„¡è™•ä¸åœ¨ã€‚æœ¬å°ˆæ¡ˆå±•ç¤ºå¦‚ä½•ä½¿ç”¨ AI è¼”åŠ©å·¥å…·ä¾†é–‹ç™¼å„ç¨®åµŒå…¥å¼å¹³å°çš„æ‡‰ç”¨ç¨‹å¼ã€é©…å‹•ç¨‹å¼å’Œç³»çµ±è»Ÿé«”ã€‚

## ğŸ¯ æ”¯æ´å¹³å°

### 1. ARM Cortex-M ç³»åˆ—
- **Cortex-M0/M0+**
  - è¶…ä½åŠŸè€—æ‡‰ç”¨
  - ç°¡å–®æ§åˆ¶ç³»çµ±
  - æ„Ÿæ¸¬å™¨ç¯€é»

- **Cortex-M3/M4**
  - å·¥æ¥­æ§åˆ¶
  - é¦¬é”é©…å‹•
  - DSP æ‡‰ç”¨ (M4F)
  - éŸ³é »è™•ç†

- **Cortex-M7**
  - é«˜æ€§èƒ½æ‡‰ç”¨
  - åœ–å½¢é¡¯ç¤º
  - è¤‡é›œæ§åˆ¶
  - å¿«é€Ÿæ•¸æ“šè™•ç†

### 2. ARM Cortex-A ç³»åˆ—
- **æ‡‰ç”¨è™•ç†å™¨**
  - Linux é‹è¡Œå¹³å°
  - Android è¨­å‚™
  - å¤šåª’é«”è™•ç†
  - ç¶²è·¯é–˜é“å™¨

- **å¸¸è¦‹å¹³å°**
  - Raspberry Pi (Cortex-A53/A72)
  - BeagleBone (Cortex-A8)
  - i.MX ç³»åˆ—
  - Rockchip RK33xx

### 3. ESP32/ESP8266
- **Wi-Fi/è—ç‰™ SoC**
  - IoT æ‡‰ç”¨é–‹ç™¼
  - æ™ºæ…§å®¶å±…
  - ç„¡ç·šæ„Ÿæ¸¬å™¨
  - Web ä¼ºæœå™¨

- **é–‹ç™¼ç‰¹è‰²**
  - Arduino æ¡†æ¶æ”¯æ´
  - ESP-IDF å®˜æ–¹æ¡†æ¶
  - MicroPython æ”¯æ´
  - ä½æˆæœ¬è§£æ±ºæ–¹æ¡ˆ

### 4. STM32 å¾®æ§åˆ¶å™¨
- **STM32F ç³»åˆ—**
  - é€šç”¨ MCU é–‹ç™¼
  - è±å¯Œå¤–è¨­æ”¯æ´
  - HAL åº«é–‹ç™¼
  - CubeMX å·¥å…·

- **STM32H/L/G ç³»åˆ—**
  - é«˜æ€§èƒ½æ‡‰ç”¨ (H7)
  - è¶…ä½åŠŸè€— (L4/L5)
  - åœ–å½¢æ‡‰ç”¨ (G4)

### 5. Raspberry Pi
- **å–®æ¿é›»è…¦**
  - Linux å®Œæ•´ç³»çµ±
  - Python å¿«é€Ÿé–‹ç™¼
  - GPIO æ§åˆ¶
  - æ•™è‚²é …ç›®

- **æ‡‰ç”¨é ˜åŸŸ**
  - å®¶åº­è‡ªå‹•åŒ–
  - åª’é«”ä¸­å¿ƒ
  - ç¶²è·¯ä¼ºæœå™¨
  - æ©Ÿå™¨å­¸ç¿’é‚Šç·£é‹ç®—

### 6. BeagleBone
- **å·¥æ¥­ç´šå–®æ¿é›»è…¦**
  - PRU (å¯ç·¨ç¨‹å¯¦æ™‚å–®å…ƒ)
  - å·¥æ¥­ I/O
  - å¯¦æ™‚æ§åˆ¶
  - Debian Linux

### 7. Arduino å¹³å°
- **å¿«é€ŸåŸå‹é–‹ç™¼**
  - åˆå­¸è€…å‹å–„
  - è±å¯Œç”Ÿæ…‹ç³»çµ±
  - å„ç¨®é–‹ç™¼æ¿
  - å¤§é‡å‡½å¼åº«

### 8. RISC-V å¹³å°
- **é–‹æºæŒ‡ä»¤é›†**
  - SiFive é–‹ç™¼æ¿
  - ESP32-C3/C6 (RISC-V)
  - æ–°èˆˆç”Ÿæ…‹ç³»çµ±
  - å­¸è¡“ç ”ç©¶

## ğŸ› ï¸ æŠ€è¡“æ£§

### é–‹ç™¼èªè¨€
- **C** - åµŒå…¥å¼ä¸»æµèªè¨€
- **C++** - ç‰©ä»¶å°å‘é–‹ç™¼
- **Rust** - å®‰å…¨ç³»çµ±ç¨‹å¼èªè¨€
- **Python** - å¿«é€ŸåŸå‹å’Œè…³æœ¬
- **MicroPython** - å¾®æ§åˆ¶å™¨ Python
- **Assembly** - é—œéµæ€§èƒ½å„ªåŒ–

### é–‹ç™¼ç’°å¢ƒ
- **IDE/ç·¨è¼¯å™¨**
  - STM32CubeIDE
  - Keil MDK
  - IAR Embedded Workbench
  - PlatformIO
  - Arduino IDE
  - Visual Studio Code

- **å·¥å…·éˆ**
  - ARM GCC
  - Clang/LLVM
  - ESP-IDF
  - Zephyr SDK
  - Yocto Project

### é™¤éŒ¯å·¥å…·
- **ç¡¬é«”é™¤éŒ¯**
  - JTAG/SWD é™¤éŒ¯å™¨
  - J-Link
  - ST-Link
  - OpenOCD
  - GDB ä¼ºæœå™¨

- **åˆ†æå·¥å…·**
  - é‚è¼¯åˆ†æå„€
  - ç¤ºæ³¢å™¨
  - ä¸²å£çµ‚ç«¯
  - Wireshark (ç¶²è·¯)

## ğŸš€ å¿«é€Ÿé–‹å§‹

### 1. ESP32 é–‹ç™¼ (Arduino æ¡†æ¶)

```cpp
// blink_led.ino
#define LED_PIN 2

void setup() {
    Serial.begin(115200);
    pinMode(LED_PIN, OUTPUT);
    Serial.println("ESP32 LED Blink");
}

void loop() {
    digitalWrite(LED_PIN, HIGH);
    Serial.println("LED ON");
    delay(1000);

    digitalWrite(LED_PIN, LOW);
    Serial.println("LED OFF");
    delay(1000);
}
```

### 2. ESP32 Wi-Fi é€£æ¥ (ESP-IDF)

```c
// wifi_example.c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"

#define WIFI_SSID "YourSSID"
#define WIFI_PASS "YourPassword"

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        printf("Got IP: " IPSTR "\n", IP2STR(&event->ip_info.ip));
    }
}

void wifi_init(void)
{
    nvs_flash_init();
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);

    esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID,
                               &wifi_event_handler, NULL);
    esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP,
                               &wifi_event_handler, NULL);

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASS,
        },
    };

    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_start();
}

void app_main(void)
{
    wifi_init();
}
```

### 3. STM32 GPIO æ§åˆ¶ (HAL åº«)

```c
// main.c
#include "stm32f4xx_hal.h"

void SystemClock_Config(void);
static void GPIO_Init(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    GPIO_Init();

    while (1)
    {
        // åˆ‡æ› LED
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
        HAL_Delay(500);
    }
}

static void GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // å•Ÿç”¨ GPIOA æ™‚é˜
    __HAL_RCC_GPIOA_CLK_ENABLE();

    // é…ç½® PA5 ç‚ºè¼¸å‡º
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}
```

### 4. Raspberry Pi GPIO (Python)

```python
# led_control.py
import RPi.GPIO as GPIO
import time

LED_PIN = 17

def setup():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(LED_PIN, GPIO.OUT)

def blink_led():
    try:
        while True:
            GPIO.output(LED_PIN, GPIO.HIGH)
            print("LED ON")
            time.sleep(1)

            GPIO.output(LED_PIN, GPIO.LOW)
            print("LED OFF")
            time.sleep(1)
    except KeyboardInterrupt:
        GPIO.cleanup()

if __name__ == "__main__":
    setup()
    blink_led()
```

## ğŸ“š é–‹ç™¼ç¯„ä¾‹

### ç¯„ä¾‹ 1: I2C æº«æ¿•åº¦æ„Ÿæ¸¬å™¨ (ESP32)

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>

#define DHTPIN 4
#define DHTTYPE DHT22

DHT dht(DHTPIN, DHTTYPE);

void setup() {
    Serial.begin(115200);
    dht.begin();
    Serial.println("DHT22 Sensor Ready");
}

void loop() {
    delay(2000);

    float humidity = dht.readHumidity();
    float temperature = dht.readTemperature();

    if (isnan(humidity) || isnan(temperature)) {
        Serial.println("Failed to read from DHT sensor!");
        return;
    }

    Serial.printf("Humidity: %.2f%%  Temperature: %.2fÂ°C\n",
                 humidity, temperature);
}
```

### ç¯„ä¾‹ 2: PWM é¦¬é”æ§åˆ¶ (STM32)

```c
#include "stm32f4xx_hal.h"

TIM_HandleTypeDef htim2;

void PWM_Init(void)
{
    TIM_OC_InitTypeDef sConfigOC = {0};

    __HAL_RCC_TIM2_CLK_ENABLE();

    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 84 - 1;  // 1 MHz
    htim2.Init.Period = 1000 - 1;   // 1 kHz PWM
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    HAL_TIM_PWM_Init(&htim2);

    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 500;  // 50% duty cycle
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);

    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
}

void SetMotorSpeed(uint16_t speed)  // 0-1000
{
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, speed);
}
```

### ç¯„ä¾‹ 3: UART é€šè¨Š (STM32)

```c
#include "stm32f4xx_hal.h"
#include <string.h>

UART_HandleTypeDef huart2;

void UART_Init(void)
{
    __HAL_RCC_USART2_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    HAL_UART_Init(&huart2);
}

void UART_SendString(const char *str)
{
    HAL_UART_Transmit(&huart2, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
}

uint8_t UART_ReceiveByte(void)
{
    uint8_t data;
    HAL_UART_Receive(&huart2, &data, 1, HAL_MAX_DELAY);
    return data;
}
```

### ç¯„ä¾‹ 4: MQTT ç‰©è¯ç¶² (ESP32)

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

const char* ssid = "YourSSID";
const char* password = "YourPassword";
const char* mqtt_server = "broker.mqtt.com";

WiFiClient espClient;
PubSubClient client(espClient);

void callback(char* topic, byte* payload, unsigned int length) {
    Serial.print("Message arrived [");
    Serial.print(topic);
    Serial.print("] ");
    for (int i = 0; i < length; i++) {
        Serial.print((char)payload[i]);
    }
    Serial.println();
}

void reconnect() {
    while (!client.connected()) {
        Serial.print("Attempting MQTT connection...");
        if (client.connect("ESP32Client")) {
            Serial.println("connected");
            client.subscribe("home/sensor/#");
        } else {
            Serial.print("failed, rc=");
            Serial.print(client.state());
            delay(5000);
        }
    }
}

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }

    client.setServer(mqtt_server, 1883);
    client.setCallback(callback);
}

void loop() {
    if (!client.connected()) {
        reconnect();
    }
    client.loop();

    // ç™¼å¸ƒæ•¸æ“š
    char msg[50];
    snprintf(msg, 50, "Temperature: %.2f", 25.5);
    client.publish("home/sensor/temperature", msg);

    delay(5000);
}
```

## ğŸ¤– AI è¼”åŠ©é–‹ç™¼ç­–ç•¥

### 1. ç¡¬é«”è¦æ ¼ç†è§£
```
"è§£é‡‹ STM32F407 çš„ DMA æ§åˆ¶å™¨å·¥ä½œåŸç†"
"ESP32 çš„é›™æ ¸å¿ƒå¦‚ä½•é€²è¡Œä»»å‹™åˆ†é…ï¼Ÿ"
"å¦‚ä½•è¨ˆç®— PWM é »ç‡å’Œå ç©ºæ¯”çš„æš«å­˜å™¨å€¼ï¼Ÿ"
```

### 2. ç¨‹å¼ç¢¼ç”Ÿæˆ
```
"ç”Ÿæˆ STM32 HAL çš„ SPI åˆå§‹åŒ–ä»£ç¢¼"
"å‰µå»º ESP32 FreeRTOS ä»»å‹™ç¯„ä¾‹"
"ç”Ÿæˆ I2C EEPROM è®€å¯«å‡½æ•¸"
```

### 3. é™¤éŒ¯å”åŠ©
```
"é€™å€‹ HardFault éŒ¯èª¤å¯èƒ½æ˜¯ä»€éº¼åŸå› ï¼Ÿ"
"ç‚ºä»€éº¼ UART æ¥æ”¶æœƒä¸Ÿå¤±æ•¸æ“šï¼Ÿ"
"å¦‚ä½•é™¤éŒ¯ FreeRTOS å †ç–Šæº¢ä½å•é¡Œï¼Ÿ"
```

### 4. æ€§èƒ½å„ªåŒ–
```
"å¦‚ä½•å„ªåŒ– ADC æ¡æ¨£é€Ÿåº¦ï¼Ÿ"
"æ¸›å°‘ ESP32 åŠŸè€—çš„æ–¹æ³•æœ‰å“ªäº›ï¼Ÿ"
"å¦‚ä½•ä½¿ç”¨ DMA æå‡æ•¸æ“šå‚³è¼¸æ•ˆç‡ï¼Ÿ"
```

## ğŸ“Š å°ˆæ¡ˆçµæ§‹

```
embedded-systems/
â”œâ”€â”€ README.md
â”œâ”€â”€ esp32/
â”‚   â”œâ”€â”€ wifi-examples/
â”‚   â”œâ”€â”€ bluetooth/
â”‚   â”œâ”€â”€ sensors/
â”‚   â””â”€â”€ iot-projects/
â”œâ”€â”€ stm32/
â”‚   â”œâ”€â”€ hal-examples/
â”‚   â”œâ”€â”€ freertos/
â”‚   â”œâ”€â”€ usb-device/
â”‚   â””â”€â”€ motor-control/
â”œâ”€â”€ raspberry-pi/
â”‚   â”œâ”€â”€ gpio-control/
â”‚   â”œâ”€â”€ camera/
â”‚   â”œâ”€â”€ automation/
â”‚   â””â”€â”€ web-server/
â”œâ”€â”€ arduino/
â”‚   â”œâ”€â”€ basic-examples/
â”‚   â”œâ”€â”€ sensors/
â”‚   â””â”€â”€ communication/
â”œâ”€â”€ cortex-m/
â”‚   â”œâ”€â”€ bare-metal/
â”‚   â”œâ”€â”€ cmsis/
â”‚   â””â”€â”€ startup-code/
â””â”€â”€ docs/
    â”œâ”€â”€ platform-guides/
    â”œâ”€â”€ hardware-setup/
    â””â”€â”€ debugging-tips/
```

## ğŸ§ª é–‹ç™¼è·¯ç·šåœ–

### Phase 1: åŸºç¤é–‹ç™¼ âœ…
- [x] GPIO æ§åˆ¶
- [x] UART é€šè¨Š
- [x] åŸºæœ¬ LED é–ƒçˆ
- [x] é–‹ç™¼ç’°å¢ƒè¨­ç½®

### Phase 2: å¤–è¨­é©…å‹• (é€²è¡Œä¸­)
- [ ] I2C/SPI é€šè¨Š
- [ ] ADC/DAC ä½¿ç”¨
- [ ] PWM è¼¸å‡º
- [ ] å®šæ™‚å™¨ä¸­æ–·

### Phase 3: é€šè¨Šå”è­°
- [ ] Wi-Fi é€£æ¥
- [ ] è—ç‰™é€šè¨Š
- [ ] MQTT ç‰©è¯ç¶²
- [ ] HTTP ä¼ºæœå™¨

### Phase 4: é€²éšæ‡‰ç”¨
- [ ] FreeRTOS å¤šä»»å‹™
- [ ] ä½åŠŸè€—è¨­è¨ˆ
- [ ] OTA æ›´æ–°
- [ ] ç”¢å“åŒ–é …ç›®

## ğŸ”¬ å­¸ç¿’è³‡æº

### æ›¸ç±æ¨è–¦
1. **Making Embedded Systems** - Elecia White
2. **Embedded Systems Architecture** - Daniele Lacamera
3. **STM32 ARM Programming for Embedded Systems**
4. **ESP32 Technical Reference Manual**

### ç·šä¸Šèª²ç¨‹
- [ESP32 Official Documentation](https://docs.espressif.com/)
- [STM32 Learning](https://www.st.com/content/st_com/en/support/learning.html)
- [Raspberry Pi Documentation](https://www.raspberrypi.org/documentation/)
- [Arduino Tutorial](https://www.arduino.cc/en/Tutorial/HomePage)

### ç¤¾ç¾¤
- [ESP32 Forum](https://www.esp32.com/)
- [STM32 Community](https://community.st.com/)
- [Arduino Forum](https://forum.arduino.cc/)
- [Raspberry Pi Forums](https://forums.raspberrypi.com/)

## âš™ï¸ é–‹ç™¼æœ€ä½³å¯¦è¸

### 1. ä½åŠŸè€—è¨­è¨ˆ
```c
// ESP32 æ·±åº¦ç¡çœ 
void enter_deep_sleep(uint64_t sleep_time_us)
{
    esp_sleep_enable_timer_wakeup(sleep_time_us);
    esp_deep_sleep_start();
}

// STM32 ä½åŠŸè€—æ¨¡å¼
void enter_stop_mode(void)
{
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
}
```

### 2. çœ‹é–€ç‹—å®šæ™‚å™¨
```c
// ESP32 çœ‹é–€ç‹—
#include "esp_task_wdt.h"

void setup() {
    esp_task_wdt_init(30, true);  // 30 ç§’è¶…æ™‚
    esp_task_wdt_add(NULL);
}

void loop() {
    // é¤µç‹—
    esp_task_wdt_reset();
}
```

### 3. éŒ¯èª¤è™•ç†
```c
// ç¡¬é«”éŒ¯èª¤è™•ç†
esp_err_t ret = i2c_master_write_byte(cmd, data, ACK_CHECK_EN);
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "I2C write failed: %s", esp_err_to_name(ret));
    return ret;
}
```

## âš ï¸ æ³¨æ„äº‹é …

### ç¡¬é«”é™åˆ¶
- **è¨˜æ†¶é«”**: MCU é€šå¸¸åªæœ‰æ•¸ KB RAM
- **Flash**: ç¨‹å¼ç©ºé–“æœ‰é™
- **æ™‚é˜**: ä½é€Ÿæ™‚é˜ç¯€çœåŠŸè€—
- **é›»æº**: æ³¨æ„é›»æµå’Œé›»å£“é™åˆ¶

### é–‹ç™¼é™·é˜±
1. **ä¸­æ–·å®‰å…¨**: ä¸­æ–·å‡½æ•¸è¦çŸ­å°å¿«é€Ÿ
2. **å †ç–Šæº¢ä½**: ç›£æ§ä»»å‹™å †ç–Šä½¿ç”¨
3. **ç«¶çˆ­æ¢ä»¶**: å¤šä»»å‹™å…±äº«è³‡æºè¦åŠ é–
4. **ç¡¬é«”å…¼å®¹**: ä¸åŒæ‰¹æ¬¡å¯èƒ½æœ‰å·®ç•°

## ğŸ“„ æˆæ¬Š

ç¯„ä¾‹ä»£ç¢¼æ¡ç”¨ MIT æˆæ¬Š

## ğŸ“ è²¢ç»

- **å•é¡Œå›å ±**: GitHub Issues
- **ç¯„ä¾‹åˆ†äº«**: Pull Requests
- **è¨è«–äº¤æµ**: GitHub Discussions

---

**æœ€å¾Œæ›´æ–°**: 2025-11-16
**ç‹€æ…‹**: ğŸš§ ç ”ç©¶èˆ‡é–‹ç™¼ä¸­
**ç¶­è­·è€…**: AI-Assisted Development Team
