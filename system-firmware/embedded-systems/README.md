# ‚ö° ÂµåÂÖ•ÂºèÁ≥ªÁµ±ÈñãÁôº
> ‰ΩøÁî® AI È©ÖÂãïÁöÑÊñπÊ≥ïÈÄ≤Ë°åÂµåÂÖ•ÂºèÁ≥ªÁµ±ÈñãÁôº

‚ö†Ô∏è **È©óË≠âÈöéÊÆµÂ∞àÊ°à** - Ê≠§È†òÂüüÁõÆÂâçËôïÊñºÁ†îÁ©∂ËàáÈñãÁôºÈöéÊÆµ

## üìã Â∞àÊ°àÊ¶ÇËø∞

ÂµåÂÖ•ÂºèÁ≥ªÁµ±ÊòØÁèæ‰ª£ÈõªÂ≠êÁî¢ÂìÅÁöÑÊ†∏ÂøÉÔºåÂæûÁâ©ËÅØÁ∂≤Ë®≠ÂÇôÂà∞Â∑•Ê•≠ÊéßÂà∂Á≥ªÁµ±ÁÑ°Ëôï‰∏çÂú®„ÄÇÊú¨Â∞àÊ°àÂ±ïÁ§∫Â¶Ç‰Ωï‰ΩøÁî® AI ËºîÂä©Â∑•ÂÖ∑‰æÜÈñãÁôºÂêÑÁ®ÆÂµåÂÖ•ÂºèÂπ≥Âè∞ÁöÑÊáâÁî®Á®ãÂºè„ÄÅÈ©ÖÂãïÁ®ãÂºèÂíåÁ≥ªÁµ±ËªüÈ´î„ÄÇ

## üéØ ÊîØÊè¥Âπ≥Âè∞

### 1. ARM Cortex-M Á≥ªÂàó
- **Cortex-M0/M0+**
  - Ë∂Ö‰ΩéÂäüËÄóÊáâÁî®
  - Á∞°ÂñÆÊéßÂà∂Á≥ªÁµ±
  - ÊÑüÊ∏¨Âô®ÁØÄÈªû

- **Cortex-M3/M4**
  - Â∑•Ê•≠ÊéßÂà∂
  - È¶¨ÈÅîÈ©ÖÂãï
  - DSP ÊáâÁî® (M4F)
  - Èü≥È†ªËôïÁêÜ

- **Cortex-M7**
  - È´òÊÄßËÉΩÊáâÁî®
  - ÂúñÂΩ¢È°ØÁ§∫
  - Ë§áÈõúÊéßÂà∂
  - Âø´ÈÄüÊï∏ÊìöËôïÁêÜ

### 2. ARM Cortex-A Á≥ªÂàó
- **ÊáâÁî®ËôïÁêÜÂô®**
  - Linux ÈÅãË°åÂπ≥Âè∞
  - Android Ë®≠ÂÇô
  - Â§öÂ™íÈ´îËôïÁêÜ
  - Á∂≤Ë∑ØÈñòÈÅìÂô®

- **Â∏∏Ë¶ãÂπ≥Âè∞**
  - Raspberry Pi (Cortex-A53/A72)
  - BeagleBone (Cortex-A8)
  - i.MX Á≥ªÂàó
  - Rockchip RK33xx

### 3. ESP32/ESP8266
- **Wi-Fi/ËóçÁâô SoC**
  - IoT ÊáâÁî®ÈñãÁôº
  - Êô∫ÊÖßÂÆ∂Â±Ö
  - ÁÑ°Á∑öÊÑüÊ∏¨Âô®
  - Web ‰º∫ÊúçÂô®

- **ÈñãÁôºÁâπËâ≤**
  - Arduino Ê°ÜÊû∂ÊîØÊè¥
  - ESP-IDF ÂÆòÊñπÊ°ÜÊû∂
  - MicroPython ÊîØÊè¥
  - ‰ΩéÊàêÊú¨Ëß£Ê±∫ÊñπÊ°à

### 4. STM32 ÂæÆÊéßÂà∂Âô®
- **STM32F Á≥ªÂàó**
  - ÈÄöÁî® MCU ÈñãÁôº
  - Ë±êÂØåÂ§ñË®≠ÊîØÊè¥
  - HAL Â∫´ÈñãÁôº
  - CubeMX Â∑•ÂÖ∑

- **STM32H/L/G Á≥ªÂàó**
  - È´òÊÄßËÉΩÊáâÁî® (H7)
  - Ë∂Ö‰ΩéÂäüËÄó (L4/L5)
  - ÂúñÂΩ¢ÊáâÁî® (G4)

### 5. Raspberry Pi
- **ÂñÆÊùøÈõªËÖ¶**
  - Linux ÂÆåÊï¥Á≥ªÁµ±
  - Python Âø´ÈÄüÈñãÁôº
  - GPIO ÊéßÂà∂
  - ÊïôËÇ≤È†ÖÁõÆ

- **ÊáâÁî®È†òÂüü**
  - ÂÆ∂Â∫≠Ëá™ÂãïÂåñ
  - Â™íÈ´î‰∏≠ÂøÉ
  - Á∂≤Ë∑Ø‰º∫ÊúçÂô®
  - Ê©üÂô®Â≠∏ÁøíÈÇäÁ∑£ÈÅãÁÆó

### 6. BeagleBone
- **Â∑•Ê•≠Á¥öÂñÆÊùøÈõªËÖ¶**
  - PRU (ÂèØÁ∑®Á®ãÂØ¶ÊôÇÂñÆÂÖÉ)
  - Â∑•Ê•≠ I/O
  - ÂØ¶ÊôÇÊéßÂà∂
  - Debian Linux

### 7. Arduino Âπ≥Âè∞
- **Âø´ÈÄüÂéüÂûãÈñãÁôº**
  - ÂàùÂ≠∏ËÄÖÂèãÂñÑ
  - Ë±êÂØåÁîüÊÖãÁ≥ªÁµ±
  - ÂêÑÁ®ÆÈñãÁôºÊùø
  - Â§ßÈáèÂáΩÂºèÂ∫´

### 8. RISC-V Âπ≥Âè∞
- **ÈñãÊ∫êÊåá‰ª§ÈõÜ**
  - SiFive ÈñãÁôºÊùø
  - ESP32-C3/C6 (RISC-V)
  - Êñ∞ËààÁîüÊÖãÁ≥ªÁµ±
  - Â≠∏Ë°ìÁ†îÁ©∂

## üõ†Ô∏è ÊäÄË°ìÊ£ß

### ÈñãÁôºË™ûË®Ä
- **C** - ÂµåÂÖ•Âºè‰∏ªÊµÅË™ûË®Ä
- **C++** - Áâ©‰ª∂Â∞éÂêëÈñãÁôº
- **Rust** - ÂÆâÂÖ®Á≥ªÁµ±Á®ãÂºèË™ûË®Ä
- **Python** - Âø´ÈÄüÂéüÂûãÂíåËÖ≥Êú¨
- **MicroPython** - ÂæÆÊéßÂà∂Âô® Python
- **Assembly** - ÈóúÈçµÊÄßËÉΩÂÑ™Âåñ

### ÈñãÁôºÁí∞Â¢É
- **IDE/Á∑®ËºØÂô®**
  - STM32CubeIDE
  - Keil MDK
  - IAR Embedded Workbench
  - PlatformIO
  - Arduino IDE
  - Visual Studio Code

- **Â∑•ÂÖ∑Èèà**
  - ARM GCC
  - Clang/LLVM
  - ESP-IDF
  - Zephyr SDK
  - Yocto Project

### Èô§ÈåØÂ∑•ÂÖ∑
- **Á°¨È´îÈô§ÈåØ**
  - JTAG/SWD Èô§ÈåØÂô®
  - J-Link
  - ST-Link
  - OpenOCD
  - GDB ‰º∫ÊúçÂô®

- **ÂàÜÊûêÂ∑•ÂÖ∑**
  - ÈÇèËºØÂàÜÊûêÂÑÄ
  - Á§∫Ê≥¢Âô®
  - ‰∏≤Âè£ÁµÇÁ´Ø
  - Wireshark (Á∂≤Ë∑Ø)

## üöÄ Âø´ÈÄüÈñãÂßã

### 1. ESP32 ÈñãÁôº (Arduino Ê°ÜÊû∂)

```cpp
// blink_led.ino
#define LED_PIN 2

void setup() {
    Serial.begin(115200);
    pinMode(LED_PIN, OUTPUT);
    Serial.println("ESP32 LED Blink");
}

void loop() {
    digitalWrite(LED_PIN, HIGH);
    Serial.println("LED ON");
    delay(1000);

    digitalWrite(LED_PIN, LOW);
    Serial.println("LED OFF");
    delay(1000);
}
```

### 2. ESP32 Wi-Fi ÈÄ£Êé• (ESP-IDF)

```c
// wifi_example.c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"

#define WIFI_SSID "YourSSID"
#define WIFI_PASS "YourPassword"

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        printf("Got IP: " IPSTR "\n", IP2STR(&event->ip_info.ip));
    }
}

void wifi_init(void)
{
    nvs_flash_init();
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);

    esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID,
                               &wifi_event_handler, NULL);
    esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP,
                               &wifi_event_handler, NULL);

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASS,
        },
    };

    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_start();
}

void app_main(void)
{
    wifi_init();
}
```

### 3. STM32 GPIO ÊéßÂà∂ (HAL Â∫´)

```c
// main.c
#include "stm32f4xx_hal.h"

void SystemClock_Config(void);
static void GPIO_Init(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    GPIO_Init();

    while (1)
    {
        // ÂàáÊèõ LED
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
        HAL_Delay(500);
    }
}

static void GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // ÂïüÁî® GPIOA ÊôÇÈêò
    __HAL_RCC_GPIOA_CLK_ENABLE();

    // ÈÖçÁΩÆ PA5 ÁÇ∫Ëº∏Âá∫
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}
```

### 4. Raspberry Pi GPIO (Python)

```python
# led_control.py
import RPi.GPIO as GPIO
import time

LED_PIN = 17

def setup():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(LED_PIN, GPIO.OUT)

def blink_led():
    try:
        while True:
            GPIO.output(LED_PIN, GPIO.HIGH)
            print("LED ON")
            time.sleep(1)

            GPIO.output(LED_PIN, GPIO.LOW)
            print("LED OFF")
            time.sleep(1)
    except KeyboardInterrupt:
        GPIO.cleanup()

if __name__ == "__main__":
    setup()
    blink_led()
```

## üìö ÈñãÁôºÁØÑ‰æã

### ÁØÑ‰æã 1: I2C Ê∫´ÊøïÂ∫¶ÊÑüÊ∏¨Âô® (ESP32)

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>

#define DHTPIN 4
#define DHTTYPE DHT22

DHT dht(DHTPIN, DHTTYPE);

void setup() {
    Serial.begin(115200);
    dht.begin();
    Serial.println("DHT22 Sensor Ready");
}

void loop() {
    delay(2000);

    float humidity = dht.readHumidity();
    float temperature = dht.readTemperature();

    if (isnan(humidity) || isnan(temperature)) {
        Serial.println("Failed to read from DHT sensor!");
        return;
    }

    Serial.printf("Humidity: %.2f%%  Temperature: %.2f¬∞C\n",
                 humidity, temperature);
}
```

### ÁØÑ‰æã 2: PWM È¶¨ÈÅîÊéßÂà∂ (STM32)

```c
#include "stm32f4xx_hal.h"

TIM_HandleTypeDef htim2;

void PWM_Init(void)
{
    TIM_OC_InitTypeDef sConfigOC = {0};

    __HAL_RCC_TIM2_CLK_ENABLE();

    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 84 - 1;  // 1 MHz
    htim2.Init.Period = 1000 - 1;   // 1 kHz PWM
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    HAL_TIM_PWM_Init(&htim2);

    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 500;  // 50% duty cycle
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);

    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
}

void SetMotorSpeed(uint16_t speed)  // 0-1000
{
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, speed);
}
```

### ÁØÑ‰æã 3: UART ÈÄöË®ä (STM32)

```c
#include "stm32f4xx_hal.h"
#include <string.h>

UART_HandleTypeDef huart2;

void UART_Init(void)
{
    __HAL_RCC_USART2_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    HAL_UART_Init(&huart2);
}

void UART_SendString(const char *str)
{
    HAL_UART_Transmit(&huart2, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
}

uint8_t UART_ReceiveByte(void)
{
    uint8_t data;
    HAL_UART_Receive(&huart2, &data, 1, HAL_MAX_DELAY);
    return data;
}
```

### ÁØÑ‰æã 4: MQTT Áâ©ËÅØÁ∂≤ (ESP32)

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

const char* ssid = "YourSSID";
const char* password = "YourPassword";
const char* mqtt_server = "broker.mqtt.com";

WiFiClient espClient;
PubSubClient client(espClient);

void callback(char* topic, byte* payload, unsigned int length) {
    Serial.print("Message arrived [");
    Serial.print(topic);
    Serial.print("] ");
    for (int i = 0; i < length; i++) {
        Serial.print((char)payload[i]);
    }
    Serial.println();
}

void reconnect() {
    while (!client.connected()) {
        Serial.print("Attempting MQTT connection...");
        if (client.connect("ESP32Client")) {
            Serial.println("connected");
            client.subscribe("home/sensor/#");
        } else {
            Serial.print("failed, rc=");
            Serial.print(client.state());
            delay(5000);
        }
    }
}

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }

    client.setServer(mqtt_server, 1883);
    client.setCallback(callback);
}

void loop() {
    if (!client.connected()) {
        reconnect();
    }
    client.loop();

    // ÁôºÂ∏ÉÊï∏Êìö
    char msg[50];
    snprintf(msg, 50, "Temperature: %.2f", 25.5);
    client.publish("home/sensor/temperature", msg);

    delay(5000);
}
```

## ü§ñ AI ËºîÂä©ÈñãÁôºÁ≠ñÁï•

### 1. Á°¨È´îË¶èÊ†ºÁêÜËß£
```
"Ëß£Èáã STM32F407 ÁöÑ DMA ÊéßÂà∂Âô®Â∑•‰ΩúÂéüÁêÜ"
"ESP32 ÁöÑÈõôÊ†∏ÂøÉÂ¶Ç‰ΩïÈÄ≤Ë°å‰ªªÂãôÂàÜÈÖçÔºü"
"Â¶Ç‰ΩïË®àÁÆó PWM È†ªÁéáÂíåÂç†Á©∫ÊØîÁöÑÊö´Â≠òÂô®ÂÄºÔºü"
```

### 2. Á®ãÂºèÁ¢ºÁîüÊàê
```
"ÁîüÊàê STM32 HAL ÁöÑ SPI ÂàùÂßãÂåñ‰ª£Á¢º"
"ÂâµÂª∫ ESP32 FreeRTOS ‰ªªÂãôÁØÑ‰æã"
"ÁîüÊàê I2C EEPROM ËÆÄÂØ´ÂáΩÊï∏"
```

### 3. Èô§ÈåØÂçîÂä©
```
"ÈÄôÂÄã HardFault ÈåØË™§ÂèØËÉΩÊòØ‰ªÄÈ∫ºÂéüÂõ†Ôºü"
"ÁÇ∫‰ªÄÈ∫º UART Êé•Êî∂ÊúÉ‰∏üÂ§±Êï∏ÊìöÔºü"
"Â¶Ç‰ΩïÈô§ÈåØ FreeRTOS Â†ÜÁñäÊ∫¢‰ΩçÂïèÈ°åÔºü"
```

### 4. ÊÄßËÉΩÂÑ™Âåñ
```
"Â¶Ç‰ΩïÂÑ™Âåñ ADC Êé°Ê®£ÈÄüÂ∫¶Ôºü"
"Ê∏õÂ∞ë ESP32 ÂäüËÄóÁöÑÊñπÊ≥ïÊúâÂì™‰∫õÔºü"
"Â¶Ç‰Ωï‰ΩøÁî® DMA ÊèêÂçáÊï∏ÊìöÂÇ≥Ëº∏ÊïàÁéáÔºü"
```

## üìä Â∞àÊ°àÁµêÊßã

```
embedded-systems/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ esp32/
‚îÇ   ‚îú‚îÄ‚îÄ wifi-examples/
‚îÇ   ‚îú‚îÄ‚îÄ bluetooth/
‚îÇ   ‚îú‚îÄ‚îÄ sensors/
‚îÇ   ‚îî‚îÄ‚îÄ iot-projects/
‚îú‚îÄ‚îÄ stm32/
‚îÇ   ‚îú‚îÄ‚îÄ hal-examples/
‚îÇ   ‚îú‚îÄ‚îÄ freertos/
‚îÇ   ‚îú‚îÄ‚îÄ usb-device/
‚îÇ   ‚îî‚îÄ‚îÄ motor-control/
‚îú‚îÄ‚îÄ raspberry-pi/
‚îÇ   ‚îú‚îÄ‚îÄ gpio-control/
‚îÇ   ‚îú‚îÄ‚îÄ camera/
‚îÇ   ‚îú‚îÄ‚îÄ automation/
‚îÇ   ‚îî‚îÄ‚îÄ web-server/
‚îú‚îÄ‚îÄ arduino/
‚îÇ   ‚îú‚îÄ‚îÄ basic-examples/
‚îÇ   ‚îú‚îÄ‚îÄ sensors/
‚îÇ   ‚îî‚îÄ‚îÄ communication/
‚îú‚îÄ‚îÄ cortex-m/
‚îÇ   ‚îú‚îÄ‚îÄ bare-metal/
‚îÇ   ‚îú‚îÄ‚îÄ cmsis/
‚îÇ   ‚îî‚îÄ‚îÄ startup-code/
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ platform-guides/
    ‚îú‚îÄ‚îÄ hardware-setup/
    ‚îî‚îÄ‚îÄ debugging-tips/
```

## üß™ ÈñãÁôºË∑ØÁ∑öÂúñ

### Phase 1: Âü∫Á§éÈñãÁôº ‚úÖ
- [x] GPIO ÊéßÂà∂
- [x] UART ÈÄöË®ä
- [x] Âü∫Êú¨ LED ÈñÉÁàç
- [x] ÈñãÁôºÁí∞Â¢ÉË®≠ÁΩÆ

### Phase 2: Â§ñË®≠È©ÖÂãï (ÈÄ≤Ë°å‰∏≠)
- [ ] I2C/SPI ÈÄöË®ä
- [ ] ADC/DAC ‰ΩøÁî®
- [ ] PWM Ëº∏Âá∫
- [ ] ÂÆöÊôÇÂô®‰∏≠Êñ∑

### Phase 3: ÈÄöË®äÂçîË≠∞
- [ ] Wi-Fi ÈÄ£Êé•
- [ ] ËóçÁâôÈÄöË®ä
- [ ] MQTT Áâ©ËÅØÁ∂≤
- [ ] HTTP ‰º∫ÊúçÂô®

### Phase 4: ÈÄ≤ÈöéÊáâÁî®
- [ ] FreeRTOS Â§ö‰ªªÂãô
- [ ] ‰ΩéÂäüËÄóË®≠Ë®à
- [ ] OTA Êõ¥Êñ∞
- [ ] Áî¢ÂìÅÂåñÈ†ÖÁõÆ

## üî¨ Â≠∏ÁøíË≥áÊ∫ê

### Êõ∏Á±çÊé®Ëñ¶
1. **Making Embedded Systems** - Elecia White
2. **Embedded Systems Architecture** - Daniele Lacamera
3. **STM32 ARM Programming for Embedded Systems**
4. **ESP32 Technical Reference Manual**

### Á∑ö‰∏äË™≤Á®ã
- [ESP32 Official Documentation](https://docs.espressif.com/)
- [STM32 Learning](https://www.st.com/content/st_com/en/support/learning.html)
- [Raspberry Pi Documentation](https://www.raspberrypi.org/documentation/)
- [Arduino Tutorial](https://www.arduino.cc/en/Tutorial/HomePage)

### Á§æÁæ§
- [ESP32 Forum](https://www.esp32.com/)
- [STM32 Community](https://community.st.com/)
- [Arduino Forum](https://forum.arduino.cc/)
- [Raspberry Pi Forums](https://forums.raspberrypi.com/)

## ‚öôÔ∏è ÈñãÁôºÊúÄ‰Ω≥ÂØ¶Ë∏ê

### 1. ‰ΩéÂäüËÄóË®≠Ë®à
```c
// ESP32 Ê∑±Â∫¶Áù°Áú†
void enter_deep_sleep(uint64_t sleep_time_us)
{
    esp_sleep_enable_timer_wakeup(sleep_time_us);
    esp_deep_sleep_start();
}

// STM32 ‰ΩéÂäüËÄóÊ®°Âºè
void enter_stop_mode(void)
{
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
}
```

### 2. ÁúãÈñÄÁãóÂÆöÊôÇÂô®
```c
// ESP32 ÁúãÈñÄÁãó
#include "esp_task_wdt.h"

void setup() {
    esp_task_wdt_init(30, true);  // 30 ÁßíË∂ÖÊôÇ
    esp_task_wdt_add(NULL);
}

void loop() {
    // È§µÁãó
    esp_task_wdt_reset();
}
```

### 3. ÈåØË™§ËôïÁêÜ
```c
// Á°¨È´îÈåØË™§ËôïÁêÜ
esp_err_t ret = i2c_master_write_byte(cmd, data, ACK_CHECK_EN);
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "I2C write failed: %s", esp_err_to_name(ret));
    return ret;
}
```

## ‚ö†Ô∏è Ê≥®ÊÑè‰∫ãÈ†Ö

### Á°¨È´îÈôêÂà∂
- **Ë®òÊÜ∂È´î**: MCU ÈÄöÂ∏∏Âè™ÊúâÊï∏ KB RAM
- **Flash**: Á®ãÂºèÁ©∫ÈñìÊúâÈôê
- **ÊôÇÈêò**: ‰ΩéÈÄüÊôÇÈêòÁØÄÁúÅÂäüËÄó
- **ÈõªÊ∫ê**: Ê≥®ÊÑèÈõªÊµÅÂíåÈõªÂ£ìÈôêÂà∂

### ÈñãÁôºÈô∑Èò±
1. **‰∏≠Êñ∑ÂÆâÂÖ®**: ‰∏≠Êñ∑ÂáΩÊï∏Ë¶ÅÁü≠Â∞èÂø´ÈÄü
2. **Â†ÜÁñäÊ∫¢‰Ωç**: Áõ£Êéß‰ªªÂãôÂ†ÜÁñä‰ΩøÁî®
3. **Á´∂Áà≠Ê¢ù‰ª∂**: Â§ö‰ªªÂãôÂÖ±‰∫´Ë≥áÊ∫êË¶ÅÂä†Èéñ
4. **Á°¨È´îÂÖºÂÆπ**: ‰∏çÂêåÊâπÊ¨°ÂèØËÉΩÊúâÂ∑ÆÁï∞

## üìÑ ÊéàÊ¨ä

ÁØÑ‰æã‰ª£Á¢ºÊé°Áî® MIT ÊéàÊ¨ä

## üìû Ë≤¢Áçª

- **ÂïèÈ°åÂõûÂ†±**: GitHub Issues
- **ÁØÑ‰æãÂàÜ‰∫´**: Pull Requests
- **Ë®éË´ñ‰∫§ÊµÅ**: GitHub Discussions

---

**ÊúÄÂæåÊõ¥Êñ∞**: 2025-11-16
**ÁãÄÊÖã**: üöß Á†îÁ©∂ËàáÈñãÁôº‰∏≠
**Á∂≠Ë≠∑ËÄÖ**: AI-Assisted Development Team
